<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D Motions Lab </title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
:root{--bg:#0b1220;--panel:#0f172a;--line:#1f2937;--ctrl:#1e293b;--text:#e2e8f0;--muted:#cbd5e1}
html,body{margin:0;height:100%;background:var(--bg);color:var(--text);overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
.panel{position:fixed;left:12px;top:0.5in;width:360px;max-height:90vh;z-index:20;background:var(--panel);border:1px solid var(--line);border-radius:12px;box-shadow:0 8px 28px rgba(0,0,0,.4);display:flex;flex-direction:column;overflow:hidden}
.dragbar{cursor:move;background:#0c1628;border-bottom:1px solid #162235;padding:8px 12px;font-weight:700;display:flex;align-items:center;gap:8px}
.dragbar .hint{margin-left:auto;font-size:12px;color:#9fb0c9}
.content{padding:12px;overflow:auto}
label{display:block;font-size:12px;margin-top:8px;color:var(--muted)}
select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:var(--ctrl);border:1px solid #334155;color:#e2e8f0}
.row{display:flex;gap:8px}.row>button{flex:1}
.mini{padding:6px 10px;border-radius:8px;background:var(--ctrl);border:1px solid #334155}
.seg{display:flex;gap:8px}
.seg button{flex:1;padding:8px 10px;border-radius:10px;background:#142033;border:1px solid #334155;color:#cbd5e1}
.seg button.on{background:#1f2c43;color:#fff;border-color:#47618e}
details{border:1px solid #162235;border-radius:10px;padding:8px;background:#0b1426;margin-top:8px}
summary{cursor:pointer;font-weight:600;color:#dbe7ff}
#log{background:#0b1220;border:1px solid #1f2937;min-height:90px;max-height:130px;overflow:auto;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap}
#msg{position:fixed;bottom:10px;left:12px;background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:12px;z-index:25}
#taskPause.paused{background:#7c2d12 !important;border-color:#fb923c !important;color:#fff !important;}
optgroup{color:#9fb0c9;font-style:normal}
.modal{position:fixed;right:16px;bottom:16px;width:min(420px,50vw);max-height:78vh;z-index:30;background:rgba(8,13,26,.96);border:1px solid #334155;border-radius:12px;backdrop-filter:blur(6px);display:none;flex-direction:column;overflow:hidden}
.modal.on{display:flex}
.modal .top{display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid #1f2a40;background:#0c1628}
.modal .top h4{margin:0;font-size:14px}
.modal .x{margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:18px;cursor:pointer}
.modal .body{padding:12px;overflow:auto}
.rom-item{border:1px solid #2a3a55;border-radius:10px;background:#101a2e;margin:8px 0;}
.rom-item summary{padding:10px 12px;list-style:none;cursor:pointer}
.rom-item summary::-webkit-details-marker{display:none}
.rom-item .inner{padding:8px 12px;border-top:1px solid #1c2941}
.rom-row{display:flex;gap:10px;font-size:13px;padding:4px 0}
.rom-row input[type=number]{
  height:22px;           /* match Cervical Rot box height */
  font-size:12px;
  padding:2px 4px;
  box-sizing:border-box;
}
.rom-head{width:160px;color:#9fb0c9}
.badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid #2a3a55;background:#132038;color:#cbd5e1;font-size:11px;margin-left:6px}
</style>
</head>
<body>
  <!-- Panel -->
  <div class="panel" id="panel">
    <div class="dragbar" id="dragbar"> 3D Motions Lab <span class="hint">drag me</span></div>
    <div class="content">

      <label>Body Region</label>
      <div class="seg">
        <button id="segUpper" class="on">Upper Body</button>
        <button id="segLower">Lower Body</button>
      </div>
<div style="display: flex; gap: 20px; align-items: flex-end;">
  <div style="flex: 1;">
    <label style="display: block;">Model</label>
    <select id="modelSel" style="width: 100%;">
      <option value="Roman">Roman</option>
      <option value="Roma">Roma</option>
    </select>
  </div>

  <div style="flex: 1;">
    <label style="display: block;">Action</label>
    <select id="actionSel" style="width: 100%;"></select>
  </div>
</div>

      <label><span id="pairLabel">Angle (°)</span></label>
      <input type="range" id="actionDeg" min="-90" max="150" step="1" value="0">
<details>
  <summary>Bone (Advanced)</summary>

  <div class="row">

    <!-- LEFT column -->
    <div style="flex:1;display:flex;flex-direction:column;gap:4px;">
      <label style="font-size:11px;display:flex;align-items:center;gap:4px;">
        <input type="checkbox" id="bone1Active" checked>
        Active
      </label>
      <select id="boneSel"></select>
    </div>

    <!-- RIGHT column -->
    <div style="flex:1;display:flex;flex-direction:column;gap:4px;">
      <label style="font-size:11px;display:flex;align-items:center;gap:4px;">
        <input type="checkbox" id="bone2Active">
        Active
      </label>
      <select id="boneSel2"></select>
    </div>

  </div>

  <div class="row">
    <div style="flex:1">
      <label>Rotate X (°)</label>
      <input type="range" min="-180" max="180" step="1" value="0" id="rx">
    </div>
    <div style="flex:1">
      <label>Rotate Y (°)</label>
      <input type="range" min="-180" max="180" step="1" value="0" id="ry">
    </div>
  </div>

  <label>Rotate Z (°)</label>
  <input type="range" min="-180" max="180" step="1" value="0" id="rz">

  <div class="row" style="margin-top:6px">
    <button id="zeroBone" class="mini">Zero Bone</button>
    <button id="zeroAll" class="mini" title="Reset everything to anatomic baseline">Zero All</button>
  </div>

</details>

 <div id="antiRow" style="display:none;">
  <label style="display:none;">
    <input id="antiBox" type="checkbox" checked>
    <span style="display:none;">Anticollision</span>
  </label>
</div>

<!-- ===== Functional Tasks (Case Mode prototype) ===== -->
<details id="funcBox" style="margin-top:10px">
  <summary>Functional Tasks (Case Mode)</summary>

  <label>Task</label>
  <select id="taskSel">
    <option value="">(Select a task…)</option>
  </select>

  <div class="row">
    <button id="taskPlay" class="mini">Play</button>
    <button id="taskPause" class="mini">Pause</button>
    <button id="taskSlow" class="mini">Slow: OFF</button>
  </div>

  <div class="mini" style="margin-top:6px;border-radius:10px;line-height:1.35">
    <div style="font-weight:700;margin-bottom:6px;">What to observe</div>
    <div id="taskObs" style="color:#cbd5e1"></div>
  </div>
</details>
      
      <details>
        <summary>Model</summary>
        <div class="row">
          <div style="flex:1">
            <label>Model X (m)</label>
            <input type="range" min="-2" max="2" step="0.01" value="0" id="mx">
          </div>
          <div style="flex:1">
            <label>Model Z (m)</label>
            <input type="range" min="-2" max="2" step="0.01" value="0.6" id="mz">
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label>Model Y (m)</label>
            <input type="range" min="-0.2" max="0.6" step="0.005" value="0" id="my">
          </div>
          <div style="flex:1">
            <label>Scale (%)</label>
            <input type="range" min="40" max="200" step="1" value="125" id="ms">
          </div>
        </div>
        <label>Yaw (°)</label>
        <input type="range" min="0" max="360" step="1" value="0" id="myaw">
        <div class="row"><button id="resetModel" class="mini">Reset Model</button></div>
      </details>

      <!-- Event Log (hidden but active) -->
<div id="eventLogBlock" style="display:none;">
  <label>Event Log</label>
  <pre id="log"></pre>
</div>

    </div>
  </div>

  <div id="msg">Loading…</div>
  <canvas id="c"></canvas>

  <script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
  import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

const MODEL_URLS = {
  Roman: "https://kingto89.github.io/ROMetrics.com/assets/Roman_ROMetrics.glb",
  Roma:  "https://kingto89.github.io/ROMetrics.com/assets/Roma_ROMetrics.glb"
};

function pickModelUrl(){
  const u = new URL(location.href);
  const qRaw = (u.searchParams.get("model") || "").trim();

  // allow ?model=Roma or ?model=Roman
  if (qRaw && MODEL_URLS[qRaw]) return MODEL_URLS[qRaw];

  // allow absolute URL or relative path
  if (qRaw && /^https?:\/\//i.test(qRaw)) return qRaw;
  if (qRaw) return new URL(qRaw, location.href).href;

  return MODEL_URLS.Roma; // default
}

let MODEL_URL = pickModelUrl();
/* =========================================
   ROM CASE TOKEN DEFINITIONS (Drop-In)
   ========================================= */
const ROM_CASE_TOKENS = {
  "LAB-CERVICAL-001": {
    caseId: "case_001",
    label: "Cervical Impairment",

    // --- UI CONTROL: Only allow Upper Body Motions ---
    allowedRegions: ["Cervical", "Shoulder", "Elbow", "Wrist"],
    disableAdvancedMenu: true, // Hide the Bone (Advanced) details menu

        // --- IMPAIRMENTS: ROM Limits (Max Measured Angles) ---
    impairments: {
      // Right Cervical Rotation (normal ~70°, cap at 30°)
      cerv_rot_r: { max: 30 },

      // Right Cervical Lateral Flexion (normal ~45°, cap at 20°)
      cerv_lat_r: { max: 20 }

      // Left side & flex/ext use default caps
    },

    // --- VISUAL FEEDBACK: Shape Keys for Pain Grimace ---
    // NOTE: deliberately NO eye* shapekeys so lashes don't move.
    painShapeKeys: [
      // Forehead / brow frown (visible "ow" in the forehead)
      { key: 'Expressions_browSqueezeR_max', value: 1.5 },

      // Strong eye squint
      { key: 'Expressions_eyeSquintL_max',   value: 0.5 },

            // Cheeks lift a bit (tight face)
      { key: 'Expressions_cheekSneerL_max',  value: 0.5 },
      { key: 'Expressions_cheekSneerR_max',  value: 0.2 },

      // Mouth: open + shifted sideways (clear discomfort)
      { key: 'Expressions_mouthOpenAggr_max',  value: 0.1 },
      { key: 'Expressions_mouthOpenLarge_max', value: 0.1 },
      { key: 'Expressions_mouthHoriz_max',      value: 0.4 },

      // Jaw follows the mouth pull
      { key: 'Expressions_jawHoriz_max',        value: 0.3 },
      { key: 'Expressions_jawOut_max',          value: 0.1 },

      // Nostrils flare a bit (pain / effort)
      { key: 'Expressions_nostrilsExpansion_max', value: 0.1 }
    ],




    // --- NOTES OVERLAY CONTENT ---
    notes: {
      constantNote: `
        Sensation:
        - Dermatomes intact
        - No radiating symptoms
      `,
      cluesNote: `
        Case Clues:
        - Direction-specific ROM loss
        - Pain-limited ROM
        - 6/10 pain score 
        - Moderate irritability
        - Mechanical pattern with positional onset
      `
    }
  },
   // =====================================
  // CASE 2 — HIP IMPAIRMENT (RIGHT HIP)
  // =====================================
  "LAB-HIP-002": {
    caseId: "case_002",
    label: "Hip ROM Loss — Right",

    // Let lower-body motions be available for this lab case
    allowedRegions: ["Hip", "Knee", "Ankle", "Foot"],
    disableAdvancedMenu: true, // Hide the Bone (Advanced) details menu

    // --- IMPAIRMENTS: ROM Limits (for future use in lab logic) ---
    impairments: {
      // Right Hip Flexion (normal ~120°, case = 50°)
      hip_flex_r: { max: 50 },

      // Right Hip Extension (normal ~15°, case = 5°)
      hip_ext_r:  { max: 5 },

      // Right Hip Abduction (normal ~45°, case = 20°)
      hip_abd_r:  { max: 20 }
    },

    painShapeKeys: [
  // ===== Brow Raise / Shock =====
  { key: 'Expressions_browsMidVert_max', value: 1.0 },     // Center brows raised high
  { key: 'Expressions_browOutVertL_max', value: 0.8 },     // Outer brow raise L
  { key: 'Expressions_browOutVertR_max', value: 0.8 },     // Outer brow raise R

//  // ===== Mouth Open (shock/pain) =====
//  { key: 'Expressions_mouthOpenAggr_max',  value: 0.4 },   // Large open mouth
//  { key: 'Expressions_mouthOpenLarge_max', value: 0.3 },   // Adds width + stretch

  // ===== Mouth shaping for pain =====
//  { key: 'Expressions_mouthHoriz_max',     value: 0.3 },   // Horizontal pull
//  { key: 'Expressions_jawOut_max',         value: 0.4 },   // Jaw thrust forward
//  { key: 'Expressions_jawHoriz_max',       value: 0.3 },   // Jaw shifts sideways slightly

  // ===== Nose tension (subtle pain effect) =====
  { key: 'Expressions_nostrilsExpansion_max', value: 0.2 } // Flared nostrils for pain
],

    // --- NOTES OVERLAY CONTENT (LAB TEXT) ---
    notes: {
      constantNote: `
        Sensation:
        - Dermatomes intact
        - No radiating symptoms
      `,

      // ✅ Hip ROM loss section + Case Clues block (from Case 2)
      cluesNote: `
        - Dull/achy anterior right hip/groin pain (4–6/10)
        - Marked right hip ROM loss 
        - No numbness, tingling, low back pain, or systemic red flags
      `
    }
  },

  // =====================================
  // CASE 3 — CLUSTER IMPAIRMENT (TRUNK)
  // =====================================
  "LAB-CLUSTER-003": {
    caseId: "case_003",
    label: "Cluster Impairment",

    allowedRegions: ["Hip", "Knee", "Ankle", "Foot"],
    disableAdvancedMenu: true, // Hide the Bone (Advanced) details menu

    impairments: {
      trunk_flexion:   { max: 20 }, // Lumbar flexion 20°
      trunk_extension: { max: 5  },  // Lumbar extension 5°
      trunk_lat_left:  { max: 15 }, // L lateral flexion 15°
      trunk_lat_right: { max: 15 }, // R lateral flexion 15°
      trunk_rot_left:   { max: 20 }, // L rotation 20°
      trunk_rot_right:   { max: 20 }  // R rotation 20°
    },

    painShapeKeys: [
      { key: 'Expressions_browSqueezeR_max',      value: 1.5 },
      { key: 'Expressions_eyeSquintL_max',        value: 0.5 },
      { key: 'Expressions_cheekSneerL_max',       value: 0.5 },
      { key: 'Expressions_cheekSneerR_max',       value: 0.2 },
      { key: 'Expressions_mouthOpenAggr_max',     value: 0.04 },
      { key: 'Expressions_mouthOpenLarge_max',    value: 0.04 },
      { key: 'Expressions_mouthHoriz_max',        value: 0.4 },
      { key: 'Expressions_jawHoriz_max',          value: 0.3 },
      { key: 'Expressions_jawOut_max',            value: 0.1 },
      { key: 'Expressions_nostrilsExpansion_max', value: 0.1 }
    ],

    notes: {
      constantNote: `
        Sensation:
        - Decreased perianal / saddle region (S3–S5)
        - Diminished along posterior thighs bilaterally
        - Reports numbness/tingling in inner thighs & perineal region
      `,
      cluesNote: `
        Case Clues:
        - Severe, constant low back pain not clearly mechanical
        - Marked lumbar ROM loss
        - Bilateral distal weakness
        - Saddle anesthesia
        - New bladder involvement (difficulty initiating urination)
      `
    }
  }
};

window.ROM_CASE_MODE = {
    active: false,
    token: null,
    impairments: {},
    notes: {},
    painShapeKeys: []
};

    
/* ===== UI ===== */
const msg = document.getElementById("msg");
const logEl = document.getElementById("log");
const log = (t)=>{ 
  logEl.textContent += t + "\n"; 
  logEl.scrollTop = logEl.scrollHeight; 
};

const panel = document.getElementById("panel");
const dragbar = document.getElementById("dragbar");

const segUpper = document.getElementById("segUpper");
const segLower = document.getElementById("segLower");

const actionSel = document.getElementById("actionSel");
const actionDeg = document.getElementById("actionDeg");
const pairLabel = document.getElementById("pairLabel");
const zeroAll = document.getElementById("zeroAll");
    
const modelSel = document.getElementById("modelSel");       
if (modelSel){
  // set dropdown to match whatever MODEL_URL resolved to
  modelSel.value = /\/Roma_/i.test(MODEL_URL) ? "Roma" : "Roman";

  modelSel.addEventListener("change", () => {
    const key = modelSel.value;
    MODEL_URL = MODEL_URLS[key] || MODEL_URLS.Roman;

    // keep URL shareable (so reload keeps the chosen model)
    const u = new URL(location.href);
    u.searchParams.set("model", key);
    history.replaceState(null, "", u);

    loadModel(); // reload with new MODEL_URL
  });
}
/* ===== TWO-DROPDOWN BONE SYSTEM ===== */
const boneSel  = document.getElementById("boneSel");   // LEFT dropdown
const boneSel2 = document.getElementById("boneSel2");  // RIGHT dropdown

const bone1Active = document.getElementById("bone1Active"); // LEFT Active checkbox
const bone2Active = document.getElementById("bone2Active"); // RIGHT Active checkbox

// Guarantee only one dropdown is active at a time
function syncBoneActive(which){
  if (which === "left"){
    bone1Active.checked = true;
    bone2Active.checked = false;
  } else {
    bone1Active.checked = false;
    bone2Active.checked = true;
  }
}

// Default: LEFT dropdown controls sliders
syncBoneActive("left");

// checkbox switching logic
bone1Active.addEventListener("change", ()=>{
  if (bone1Active.checked) syncBoneActive("left");
});

bone2Active.addEventListener("change", ()=>{
  if (bone2Active.checked) syncBoneActive("right");
});

// Which dropdown should sliders use?
function getActiveBoneSel(){
  return bone2Active.checked ? boneSel2 : boneSel;
}

/* ===== Bone rotation sliders ===== */
const rx = document.getElementById("rx");
const ry = document.getElementById("ry");
const rz = document.getElementById("rz");
const zeroBone = document.getElementById("zeroBone");

/* ===== Model transform sliders ===== */
const mx = document.getElementById("mx");
const my = document.getElementById("my");
const mz = document.getElementById("mz");
const ms = document.getElementById("ms");
const myaw = document.getElementById("myaw");
const resetModel = document.getElementById("resetModel");

  /* ===== Collision limits (Safe ROM line; dev-tuned) ===== */
const COLLIM = {
  enabled: false,
  // ===== Existing upper body =====
  trunkLatLMax: 40,
  trunkLatRMax: 40,
  trunkFlexMax: 80,
  trunkExtMax: 60,
  cervLatLMax: 45,   // Cervical lat flex left WNL
  cervLatRMax: 45,   // Cervical lat flex right WNL
  cervRotLMax: 80,
  cervRotRMax: 80,
  shExtLMax: 60, shExtRMax: 60,
  shAddLMax: 23, shAddRMax: 23,
  shFlexLMax: 110, shFlexRMax: 110,
  shAbdLMax: 150, shAbdRMax: 150,
  shIRLMax: 37, shIRRMax: 37,
  shERLMax: 90, shERRMax: 90,
  elExtLMax: 10, elExtRMax: 10,
  elFlexLMax: 120, elFlexRMax: 120,
  wrSupLMax: 45, wrSupRMax: 45,

  // ===== NEW lower body defaults =====
  hipFlexLMax: 105, hipFlexRMax: 105,
  hipExtLMax: 30,  hipExtRMax: 30,
  hipAbdLMax: 45,  hipAbdRMax: 45,
  hipAddLMax: 25,  hipAddRMax: 25,
  kneeFlexLMax: 150, kneeFlexRMax: 150,
  kneeExtLMax: 5,   kneeExtRMax: 5,
  anklePF_LMax: 50, anklePF_RMax: 50,
  ankleDF_LMax: 20, ankleDF_RMax: 20,
  footInvLMax: 35,  footInvRMax: 35,
  footEvLMax: 20,   footEvRMax: 20,
  load() {},
  save() {}
};

function capFor(action){
  COLLIM.load();  // ✅ refresh saved limits before applying
  if(!COLLIM.enabled || !action) return null; // no cap
  const { key, sign } = action; // sign: +1 or -1
    // Cervical rotation L/R
    if(key==='cerv_rot') return (sign>0) ? COLLIM.cervRotLMax : COLLIM.cervRotRMax; // + = Left, - = Right
       // Shoulder flex/ext → cap BOTH flexion (+1) and extension (−1)
    if (/^sh_fe_/.test(key)) {
      const isLeft = key.endsWith('_l');
      if (sign > 0) { // Flexion
        return isLeft ? COLLIM.shFlexLMax : COLLIM.shFlexRMax;
      } else {        // Extension
        return isLeft ? COLLIM.shExtLMax  : COLLIM.shExtRMax;
      }
    }

// Shoulder Abd/Add — + = Abduction, − = Adduction (both sides)
if (/^sh_aa_/.test(key)) {
  const isLeft = key.endsWith('_l');

  if (sign > 0) {
    // Abduction
    return isLeft ? COLLIM.shAbdLMax : COLLIM.shAbdRMax;
  } else {
    // Adduction
    return isLeft ? COLLIM.shAddLMax : COLLIM.shAddRMax;
  }
}


    // Shoulder IR/ER caps
if (/^sh_irer_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (sign > 0) { // Internal Rotation
    return isLeft ? COLLIM.shIRLMax : COLLIM.shIRRMax;
  } else { // External Rotation
    return isLeft ? COLLIM.shERLMax : COLLIM.shERRMax;
  }
}
  // === Elbow Flexion / Extension ===
if (/^el_fe_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (sign > 0) { 
    // Flexion
    return isLeft ? COLLIM.elFlexLMax : COLLIM.elFlexRMax;
  } else if (sign < 0) {
    // Extension
    return isLeft ? COLLIM.elExtLMax : COLLIM.elExtRMax;
  }
}
    // Wrist PS → cap supination only. NOTE: in our menu below, Supination is the NEGATIVE direction (sign -1)
    if(/^wr_ps_/.test(key) && sign<0){
      return key.endsWith('_l') ? COLLIM.wrSupLMax : COLLIM.wrSupRMax;
    }
    // Trunk lateral (existing)
    if(key==='trunk_lat') return (sign>0) ? COLLIM.trunkLatLMax : COLLIM.trunkLatRMax;
    // Trunk flexion / extension
    if(key==='trunk_fe') return (sign>0) ? COLLIM.trunkFlexMax : COLLIM.trunkExtMax;

      // Cervical lateral flexion
    if(key==='cerv_lat')  return (sign>0) ? COLLIM.cervLatLMax  : COLLIM.cervLatRMax;

    // Hip Flexion (both)
if(/^hip_fe_/.test(key)){
  if (sign > 0) return key.endsWith('_l') ? COLLIM.hipFlexLMax : COLLIM.hipFlexRMax;
}
// Hip Abduction / Adduction
if (/^hip_aa_/.test(key)) {
  const isLeft = key.endsWith('_l');
  if (isLeft) {
    // Left: + = Abduction, − = Adduction
    return (sign > 0) ? COLLIM.hipAbdLMax : COLLIM.hipAddLMax;
  } else {
    // Right: + = Adduction, − = Abduction
    return (sign > 0) ? COLLIM.hipAddRMax : COLLIM.hipAbdRMax;
  }
}

// Knee Flexion / Extension (only flexion capped)
if(/^knee_fe_/.test(key)){
  if(sign > 0) return key.endsWith('_l') ? COLLIM.kneeFlexLMax : COLLIM.kneeFlexRMax;
  if(sign < 0) return null; // no cap on extension
}

// Ankle PF / DF
if(/^ankle_dfpf_/.test(key)){
  if(sign > 0) return key.endsWith('_l') ? COLLIM.anklePF_LMax : COLLIM.anklePF_RMax;
  if(sign < 0) return key.endsWith('_l') ? COLLIM.ankleDF_LMax : COLLIM.ankleDF_RMax;
}

// Foot Inversion / Eversion
if(/^foot_invev_/.test(key)){
  if(sign > 0) return key.endsWith('_l') ? COLLIM.footEvLMax : COLLIM.footEvRMax;
  if(sign < 0) return key.endsWith('_l') ? COLLIM.footInvLMax : COLLIM.footInvRMax;
}
    return null;
  }
/* =========================================================
   Functional Tasks (Case Mode prototype)
   - Shows when URL has ?caseToken=LAB-____-###  (preferred)
     OR legacy: ?case=1 (shows all) OR ?case=003 (filters)
   - Plays scripted sequences using your existing setPair()
   ========================================================= */
const QS = new URLSearchParams(location.search);
const CASE_TOKEN  = QS.get("caseToken") || "";
const LEGACY_CASE = QS.get("case") || "";

// Extract 001/002/003 from: LAB-CERVICAL-001, LAB-HIP-002, LAB-CLUSTER-003
const CASE_NUM = (() => {
  const m = String(CASE_TOKEN).match(/(\d{3})\b/);
  return m ? m[1] : "";
})();

// Legacy numeric support: ?case=003 (filters) OR ?case=1 (show all like before)
const LEGACY_NUM = (() => {
  const v = String(LEGACY_CASE).trim();
  if (!v) return "";
  if (v === "1") return "";              // legacy "on" toggle (no filtering)
  if (/^\d{1,3}$/.test(v)) return v.padStart(3, "0");
  return "";
})();

const ACTIVE_NUM = CASE_NUM || LEGACY_NUM;

// ✅ show UI if we have a caseToken, OR legacy case=1 toggle, OR legacy numeric
const CASE_MODE = (!!CASE_TOKEN) || (LEGACY_CASE === "1") || (!!LEGACY_NUM);

const funcBox   = document.getElementById("funcBox");
const taskSel   = document.getElementById("taskSel");
const taskPlay  = document.getElementById("taskPlay");
const taskPause = document.getElementById("taskPause");
const taskSlow  = document.getElementById("taskSlow");
const taskObs   = document.getElementById("taskObs");

if (funcBox) funcBox.style.display = CASE_MODE ? "block" : "none";

/* -----------------------
   ALL TASKS (full logic lives here)
   Tag each task with caseNum so we can filter by 001/002/003.
------------------------ */
const ALL_FUNC_TASKS = {
  March_Alt_RHip: {
    caseNum: "002",
    label: "March — Case 2",
    obs: [
      "RIGHT knee lift stops early (hip flex limit on R)",
      "Asymmetry: trunk/pelvis strategy differs L vs R"
    ],
    steps: [
      // neutral
      { dur: 0.35, targets: {
        trunk_fe: 0, trunk_lat: 0,
        hip_fe_l: 0, knee_fe_l: 0, ankle_dfpf_l: 0,
        hip_fe_r: 0, knee_fe_r: 0, ankle_dfpf_r: 0
      }},

      // LEFT knee up (RIGHT stance) → show RIGHT trunk lean
      { dur: 0.65, targets: { hip_fe_l: 95, knee_fe_l: -90, ankle_dfpf_l: 12, trunk_lat: 14, trunk_fe: 4 } },
      { dur: 0.35, targets: { hip_fe_l: 0,  knee_fe_l: 0,   ankle_dfpf_l: 0, trunk_lat: 0,  trunk_fe: 0 } },

      // RIGHT knee up (R hip deficit) → reduced lift
      { dur: 0.65, targets: { hip_fe_r: 32, knee_fe_r: -45, ankle_dfpf_r: 6, trunk_lat: 4, trunk_fe: 6 } },
      { dur: 0.35, targets: { hip_fe_r: 0,  knee_fe_r: 0,   ankle_dfpf_r: 0, trunk_lat: 0, trunk_fe: 0 } },
    ],
    loop: 3
  },
  Cervical_Alt_RDeficit: {
        caseNum: "001",
    label: "Cervical  — Case 1",
    obs: [
      "LEFT = uninvolved (full range, minimal trunk)",
      "RIGHT = involved (stops early), trunk rotates/leans RIGHT to compensate"
    ],
    steps: [
      // neutral
      { dur: 0.30, targets: { cerv_rot: 0, cerv_lat: 0, trunk_rot: 0, trunk_lat: 0 } },

      // LEFT look over shoulder (normal)  ✅ left rot = +
      { dur: 0.65, targets: { cerv_rot: 60, trunk_rot: 0 } },
      { dur: 0.30, targets: { cerv_rot: 0, trunk_rot: 0 } },

      // RIGHT look over shoulder (limited) ✅ right rot = -
      { dur: 0.65, targets: { cerv_rot: -30, trunk_rot: -25 } }, // trunk cheat RIGHT
      { dur: 0.30, targets: { cerv_rot: 0, trunk_rot: 0 } },

      // LEFT sidebend (normal) ✅ left lat flex = -
      { dur: 0.55, targets: { cerv_lat: -45, trunk_lat: 0 } },
      { dur: 0.30, targets: { cerv_lat: 0, trunk_lat: 0 } },

      // RIGHT sidebend (limited) ✅ right lat flex = +
      { dur: 0.55, targets: { cerv_lat: 20, trunk_lat: 12 } },  // trunk cheat RIGHT
      { dur: 0.30, targets: { cerv_lat: 0, trunk_lat: 0 } }
    ],
    loop: 2
  },

Walk_Alt_Lumbar_Case3: {
      caseNum: "003",
  label: "Walk (in place) — Case 3 ",
  obs: [
    "Guarded gait: minimal trunk rotation, slight forward trunk flexion (pain avoidance)",
    "Short step length + slow cadence (antalgic pattern)",
    "BILATERAL foot drop tendency in swing & steppage compensation",
  ],
  steps: [
    // neutral (guarded posture) + FORCE arms down + wrists neutral
    { dur: 0.45, targets: {
      trunk_fe: 10, trunk_lat: 0, trunk_rot: 0,
      hip_fe_l: 0, knee_fe_l: 0, ankle_dfpf_l: 0,
      hip_fe_r: 0, knee_fe_r: 0, ankle_dfpf_r: 0,

      // ✅ neutralize “anatomic hands”
      wr_ps_l: 0, wr_ps_r: 0,
      el_fe_l: 10, el_fe_r: 10
    }},

    // LEFT swing (RIGHT stance)
    { dur: 0.95, targets: {
      hip_fe_l: 30, knee_fe_l: -60, ankle_dfpf_l: -10,   // swing: PF toe-drop tendency
      hip_fe_r: -6, knee_fe_r: 0,   ankle_dfpf_r: -6,    // stance: cautious push-off

      trunk_fe: 12, trunk_rot: -7, trunk_lat: 10,         // guarded trunk (minimal rotation)

      // ✅ keep wrists neutral (no preset-looking hands)
      wr_ps_l: 0, wr_ps_r: 0,
      el_fe_l: 15, el_fe_r: 20
    }},
    { dur: 0.35, targets: {
      hip_fe_l: 8, knee_fe_l: -10, ankle_dfpf_l: -4,
      hip_fe_r: 0, knee_fe_r: 0,   ankle_dfpf_r: -4,

      trunk_fe: 10, trunk_rot: 0, trunk_lat: 0,

      wr_ps_l: 0, wr_ps_r: 0,
      el_fe_l: 10, el_fe_r: 10
    }},

    // RIGHT swing (LEFT stance)
    { dur: 0.95, targets: {
      hip_fe_r: 35, knee_fe_r: -60, ankle_dfpf_r: -10,
      hip_fe_l: -6, knee_fe_l: 0,   ankle_dfpf_l: -6,

      trunk_fe: 12, trunk_rot: 7, trunk_lat: -10,

      wr_ps_l: 0, wr_ps_r: 0,
      el_fe_l: 20, el_fe_r: 15
    }},
    { dur: 0.35, targets: {
      hip_fe_r: 8, knee_fe_r: -10, ankle_dfpf_r: -4,
      hip_fe_l: 0, knee_fe_l: 0,   ankle_dfpf_l: -4,

      trunk_fe: 10, trunk_rot: 0, trunk_lat: 0,
      
      wr_ps_l: 0, wr_ps_r: 0,
      el_fe_l: 10, el_fe_r: 10
    }},
  ],
  loop: 4
}

 
};

    const FUNC_TASKS = (() => {
  if (!CASE_MODE) return {};
  if (!ACTIVE_NUM) return ALL_FUNC_TASKS; // legacy case=1 (show all)
  const out = {};
  for (const [id, t] of Object.entries(ALL_FUNC_TASKS)) {
    if (t.caseNum === ACTIVE_NUM) out[id] = t; // STRICT: only matching case
  }
  return out;
})();


const FUNC = {
  speed: 1, // 1 = normal, >1 = slower
  active: false,
  paused: false,
  raf: null,
  taskId: "",
  stepIndex: 0,
  stepT0: 0,
  pose: {},        // last “committed” angles we set per key
  loopsLeft: 0
};
// ===== Functional ↔ Manual pose isolation =====
function snapPose(){
  const snap = [];
  for (const obj of initialBoneRot.keys()){
    if (obj?.quaternion) snap.push([obj, obj.quaternion.clone()]);
  }
  return snap;
}

function restorePose(snap){
  if (!snap) return;
  for (const [obj,q] of snap){
    if (obj?.quaternion && q) obj.quaternion.copy(q);
  }
  if (JOINT_BIND) JOINT_BIND.forEach(b=>{
    if (b?.bone) b.qBind = b.bone.quaternion.clone();
  });
}

// stores the manual pose only while a functional run is active
FUNC.manualSnap = null;

function easeInOut(t){
  t = Math.max(0, Math.min(1, t));
  return t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2)/2;
}

function funcLockUI(lock){
  // keep it simple: while a functional task is running, lock manual actions
  actionSel.disabled = !!lock;
  actionDeg.disabled = !!lock;
  segUpper.disabled  = !!lock;
  segLower.disabled  = !!lock;
const autoMoveBtn = document.getElementById("autoMoveBtn");
if (autoMoveBtn) autoMoveBtn.disabled = !!lock;

  // also block “Zero All” during play (optional)
  zeroAll.disabled = !!lock;

  // buttons
  taskPlay.disabled  = !!lock;
  taskPause.disabled = !lock;
  taskSlow.disabled = false;
}

function funcApplyBaseline(){
  resetAllBonesToInitial();
  applyAnatomicBaseline();
  // keep binds consistent with baseline
  if (JOINT_BIND) JOINT_BIND.forEach(b=>{
    if (b?.bone) b.qBind = b.bone.quaternion.clone();
  });
}


function funcSetAngle(key, deg){
  FUNC.pose[key] = deg;
  setPair(key, deg);
}

function funcStart(taskId){
  if (!skeleton) { msg.textContent = "Model not loaded yet."; return; }
  if (!CASE_MODE) return;

  const t = FUNC_TASKS[taskId];
  if (!t) return;

  FUNC.active = true;
  FUNC.paused = false;
  FUNC.taskId = taskId;
  FUNC.stepIndex = 0;
  FUNC.stepT0 = performance.now();
  FUNC.pose = {}; // start from 0 baseline values
  FUNC.loopsLeft = Math.max(1, t.loop || 1);
  FUNC.manualSnap = snapPose();   // remember whatever the user was doing in the main menu

  // baseline pose (so we don’t “stack” onto random prior state)
  funcApplyBaseline();
  funcLockUI(true);

  msg.textContent = `Functional Task: ${t.label}`;
  log(`▶ Functional Task START: ${t.label}`);

  funcTick();
}

function funcPauseToggle(){
  if (!FUNC.active) return;
// ✅ if dropdown no longer matches the running task, do NOT allow resume
if (!FUNC.taskId || (taskSel && taskSel.value !== FUNC.taskId)) {
  funcStop(true);
  FUNC.taskId = "";
  taskPause.classList.remove("paused");
  taskPause.textContent = "Pause";
  taskPause.disabled = true;
  taskPlay.disabled = !taskSel.value;
  msg.textContent = "Functional cleared (task changed).";
  return;
}


  // ✅ toggle first
  FUNC.paused = !FUNC.paused;
  taskPause.classList.toggle("paused", FUNC.paused);
  taskPause.textContent = FUNC.paused ? "Resume" : "Pause";


  // ✅ paused = unlock manual UI, running = lock it
  if (FUNC.paused){
    funcLockUI(false);
    taskPlay.disabled  = true;
    taskPause.disabled = false;

    if (FUNC.raf) cancelAnimationFrame(FUNC.raf);
    FUNC.raf = null;
    msg.textContent = "Functional Task: paused";
    return;
  }

  // ✅ resume
  funcLockUI(true);
  FUNC.stepT0 = performance.now();
  msg.textContent = "Functional Task: resumed";
  funcTick();
}


function funcStop(resetPose=true){
  if (FUNC.raf) cancelAnimationFrame(FUNC.raf);
  FUNC.raf = null;

  FUNC.active = false;
  FUNC.paused = false;

  funcLockUI(false);

  // IMPORTANT: restore the manual pose so functional never carries over
  if (FUNC.manualSnap){
    restorePose(FUNC.manualSnap);
    FUNC.manualSnap = null;
  } else if (resetPose){
    funcApplyBaseline();
  }

  msg.textContent = resetPose ? "Functional Task: reset" : "Functional Task: stopped";
  log(`■ Functional Task STOP`);
}

function funcTick(){
  if (!FUNC.active || FUNC.paused) return;

  const task = FUNC_TASKS[FUNC.taskId];
  const step = task.steps[FUNC.stepIndex];

  if (!step){
    FUNC.loopsLeft -= 1;
    if (FUNC.loopsLeft > 0){
      FUNC.stepIndex = 0;
      FUNC.stepT0 = performance.now();
      FUNC.raf = requestAnimationFrame(funcTick);
      return;
    }
    funcStop(true);
    msg.textContent = "Functional Task complete.";
    return;
  }

  const now = performance.now();
  const durMs = Math.max(0.05, step.dur || 0.5) * 1000 * (FUNC.speed || 1);
 const p = Math.min(1, (now - FUNC.stepT0) / durMs);
  const e = easeInOut(p);

  const targets = step.targets || {};

  // interpolate only keys listed in this step
  for (const key of Object.keys(targets)){
    const a0 = (typeof FUNC.pose[key] === "number") ? FUNC.pose[key] : 0;
    const a1 = targets[key];
    let a  = a0 + (a1 - a0) * e;

    // ✅ APPLY LIMITS DURING FUNCTIONAL PLAYBACK
    if (COLLIM.enabled){
      const isL = key.endsWith("_l");
      const isR = key.endsWith("_r");

      // Hip FE: + = flex, - = ext
      if (key.startsWith("hip_fe_")){
        const capFlex = isL ? COLLIM.hipFlexLMax : COLLIM.hipFlexRMax;
        const capExt  = isL ? COLLIM.hipExtLMax  : COLLIM.hipExtRMax;
        if (a > 0) a = Math.min(a, capFlex);
        if (a < 0) a = Math.max(a, -capExt);
      }

      // Knee FE on your task keys: flexion is NEGATIVE
      if (key.startsWith("knee_fe_")){
        const capFlex = isL ? COLLIM.kneeFlexLMax : COLLIM.kneeFlexRMax;
        if (a < 0) a = -Math.min(Math.abs(a), capFlex);
      }

      // Ankle DF/PF: DF is +, PF is -
      if (key.startsWith("ankle_dfpf_")){
        const capPF = isL ? COLLIM.anklePF_LMax : COLLIM.anklePF_RMax;
        const capDF = isL ? COLLIM.ankleDF_LMax : COLLIM.ankleDF_RMax;
        if (a > 0) a = Math.min(a, capDF);
        if (a < 0) a = Math.max(a, -capPF);
      }
    }

    setPair(key, a);
  }

  if (p >= 1){
    // commit end angles (DON’T re-setPair here — last frame already applied clamps)
    for (const key of Object.keys(targets)){
      FUNC.pose[key] = targets[key];
    }
    FUNC.stepIndex += 1;
    FUNC.stepT0 = performance.now();
  }

  FUNC.raf = requestAnimationFrame(funcTick);
}


function initFunctionalUI(){
  if (!taskSel) return;

  // fill dropdown
  Object.entries(FUNC_TASKS).forEach(([id, t])=>{
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = t.label;
    taskSel.appendChild(opt);
  });

  // observe text
taskSel.addEventListener("change", ()=>{
  const sel = taskSel.value || "";
  const t = FUNC_TASKS[sel];

  taskObs.innerHTML = t
    ? `<ul style="margin:0;padding-left:16px">${t.obs.map(x=>`<li>${x}</li>`).join("")}</ul>`
    : "";

  // HARD cancel any running/paused functional as soon as dropdown changes (including blank)
  if (FUNC.active || FUNC.paused) {
    funcStop(true);
    FUNC.taskId = ""; // invalidate
  }

  // reset Pause UI state
  taskPause.classList.remove("paused");
  taskPause.textContent = "Pause";
  taskPause.disabled = true;

  // only allow Play if a task is selected
  taskPlay.disabled = !sel;

  msg.textContent = sel ? "Task selected." : "Select a Functional Task.";
});



  taskPlay.onclick = ()=> {
    if (!taskSel.value) { msg.textContent = "Select a Functional Task first."; return; }
    // reset Action UI so it’s not “active business” during functional
actionSel.value = "";
CURRENT_ACTION = null;
actionDeg.value = "0";
actionDeg.disabled = true;
pairLabel.textContent = "Angle (°)";
resetPainExpression();

    funcStart(taskSel.value);
  };

  taskPause.onclick = ()=> funcPauseToggle();
  taskSlow.onclick = ()=> {
  FUNC.speed = (FUNC.speed === 1) ? 2.5 : 1;  // toggle slow
  taskSlow.textContent = (FUNC.speed === 1) ? "Slow: OFF" : "Slow: ON";
};

  // default button states
  taskPause.disabled = true;
  taskSlow.disabled = false;
}

initFunctionalUI();
    
 function breakFunctionalBecauseActionMoved(){
  if (!FUNC.active && !FUNC.paused) return;
  funcStop(true);                 // hard reset functional + baseline
  taskPause.textContent = "Pause";
  msg.textContent = "Functional cleared (Action used).";
}
   
  /* ===== Draggable panel ===== */
  (function(){
    let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
    const onDown = (e)=>{ dragging=true; sx=e.clientX; sy=e.clientY;
      const r = panel.getBoundingClientRect();
      startLeft = r.left; startTop = r.top;
      e.preventDefault();
    };
    const onMove = (e)=>{ if(!dragging) return;
      const dx = e.clientX - sx, dy = e.clientY - sy;
      panel.style.left = Math.max(8, startLeft + dx) + "px";
      panel.style.top = Math.max(8, startTop + dy) + "px";
    };
    const onUp = ()=>{ dragging = false; };
    dragbar.addEventListener("pointerdown", onDown);
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
  })();

  /* ===== Three setup ===== */
  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.shadowMap.enabled = false;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 100);
  camera.position.set(1.6, 1.6, 3.2);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;
  controls.minDistance = 0.6; controls.maxDistance = 6;
  controls.target.set(0,1.1,0);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 0.7));
  const key = new THREE.DirectionalLight(0xffffff, 1.2);
  key.position.set(2.5,4,2.5);
  key.castShadow = true;
  key.shadow.mapSize.set(2048,2048);
  key.shadow.camera.near = 0.1; key.shadow.camera.far = 15;
  key.shadow.camera.left = -4; key.shadow.camera.right = 4; key.shadow.camera.top = 4; key.shadow.camera.bottom = -4;
  scene.add(key);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.ShadowMaterial({ opacity: 0.45 }));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  /* ===== Loader (UNCHANGED loading flow) ===== */
  const loader = new GLTFLoader();
  loader.setMeshoptDecoder(MeshoptDecoder);
  const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
  const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

  let model = null, skeleton = null;
  const initialBoneRot = new Map();
  let FACE_MESH = null;
  function findFaceMesh(){
    if (!model) return null;
    if (FACE_MESH) return FACE_MESH;

    let candidate = null;
    model.traverse(o => {
      if (o.isSkinnedMesh && o.morphTargetDictionary){
        const lname = (o.name || "").toLowerCase();
        if (!candidate) candidate = o;
        if (lname.includes("head") || lname.includes("face")){
          candidate = o;
        }
      }
    });
    FACE_MESH = candidate;
    return FACE_MESH;
  }

  function groundSnap(){
    if (!model) return;
    const box = new THREE.Box3().setFromObject(model);
    const minY = box.min.y;
    if (isFinite(minY)) model.position.y -= minY;
  }

function populateBones(){
  boneSel.innerHTML = "";
  boneSel2.innerHTML = "";
  if (!skeleton) return;

  // ----- Groups for each dropdown -----
  const spineGroup  = document.createElement("optgroup");
  spineGroup.label  = "Spine & Head";
  const leftGroup   = document.createElement("optgroup");
  leftGroup.label   = "Left Side";

  const spineGroup2 = document.createElement("optgroup");
  spineGroup2.label = "Spine & Head";
  const rightGroup2 = document.createElement("optgroup");
  rightGroup2.label = "Right Side";

  boneSel.appendChild(spineGroup);
  boneSel.appendChild(leftGroup);

  boneSel2.appendChild(spineGroup2);
  boneSel2.appendChild(rightGroup2);
// ==========================================================
//  NEW ROM CASE LOGIC HERE (REPLACEMENT FOR STEP 2A)
// ==========================================================


  // ----- Collect bones first so we can sort by ORDER_MAP -----
  const spineArr = [];
  const leftArr  = [];
  const rightArr = [];

  skeleton.bones.forEach((b, i) => {
    const name = (b.name || "").toLowerCase();
    if (!name) return;

    if (!initialBoneRot.has(b)) {
      initialBoneRot.set(b, b.quaternion.clone());
    }

    const entry = { boneIndex: i, nameLower: name, label: b.name };

    const isMidline =
      name.startsWith("spine") ||
      name === "neck" ||
      name === "head" ||
      name.includes("breast");

    const isLeft  = !isMidline && (name.endsWith("_l") || name.endsWith(".l"));
    const isRight = !isMidline && (name.endsWith("_r") || name.endsWith(".r"));

    if (isMidline) {
      spineArr.push(entry);          // goes in BOTH dropdowns
    } else if (isLeft) {
      leftArr.push(entry);           // ONLY left dropdown
    } else if (isRight) {
      rightArr.push(entry);          // ONLY right dropdown
    }
  });

  // ----- Sort using ORDER_MAP (head → toes) -----
  const orderKey = (e) => {
    const n = e.nameLower;
    const idx = (ORDER_MAP[n] !== undefined) ? ORDER_MAP[n] : 9999;
    return idx * 100 + e.boneIndex;  // stable-ish
  };

  [spineArr, leftArr, rightArr].forEach(arr => arr.sort((a,b) => orderKey(a) - orderKey(b)));

  // ----- Append in sorted order -----
  spineArr.forEach(e => {
    const opt1 = document.createElement("option");
    opt1.value = String(e.boneIndex);
    opt1.textContent = e.label;
    spineGroup.appendChild(opt1);

    const opt2 = document.createElement("option");
    opt2.value = String(e.boneIndex);
    opt2.textContent = e.label;
    spineGroup2.appendChild(opt2);
  });

  leftArr.forEach(e => {
    const opt = document.createElement("option");
    opt.value = String(e.boneIndex);
    opt.textContent = e.label;
    leftGroup.appendChild(opt);
  });

  rightArr.forEach(e => {
    const opt = document.createElement("option");
    opt.value = String(e.boneIndex);
    opt.textContent = e.label;
    rightGroup2.appendChild(opt);
  });

  // Default to first spine bone if available
  if (spineGroup.children.length) {
    const firstVal = spineGroup.children[0].value;
    boneSel.value  = firstVal;
    boneSel2.value = firstVal;
  }

  rx.value = ry.value = rz.value = "0";
  setBoneRotationFromUI();
}

  // ----- STRICT ORDER MAP (head → toes) -----
  const ORDER = [
    "spine01","spine02","spine03",
    "neck","head",

      // Upper torso (your added bones)
    "breast_l","breast_r",

    "clavicle_l","upperarm_l","upperarm_twist_l","lowerarm_l","lowerarm_twist_l",
    "hand_l","thumb01_l","thumb02_l","thumb03_l",
    "index00_l","index01_l","index02_l","index03_l",
    "middle00_l","middle01_l","middle02_l","middle03_l",
    "ring00_l","ring01_l","ring02_l","ring03_l",
    "pinky00_l","pinky01_l","pinky02_l","pinky03_l",
    "thigh_l","thigh_twist_l","calf_l","calf_twist_l","foot_l","toes_l",

    "clavicle_r","upperarm_r","upperarm_twist_r","lowerarm_r","lowerarm_twist_r",
    "hand_r","thumb01_r","thumb02_r","thumb03_r",
    "index00_r","index01_r","index02_r","index03_r",
    "middle00_r","middle01_r","middle02_r","middle03_r",
    "ring00_r","ring01_r","ring02_r","ring03_r",
    "pinky00_r","pinky01_r","pinky02_r","pinky03_r",
    "thigh_r","thigh_twist_r","calf_r","calf_twist_r","foot_r","toes_r"
  ];

  const ORDER_MAP = Object.fromEntries(
    ORDER.map((n,i)=>[n, i])
  );


/* ===== Apply rotation from sliders ===== */
function setBoneRotationFromUI(){
  const activeSel = getActiveBoneSel();     // ✅ FIX — use active dropdown
  const idx = parseInt(getActiveBoneSel().value || "-1", 10);

  if (!skeleton || isNaN(idx) || !skeleton.bones[idx]) return;
  const b = skeleton.bones[idx];

  const ex = THREE.MathUtils.degToRad(parseFloat(rx.value)||0);
  const ey = THREE.MathUtils.degToRad(parseFloat(ry.value)||0);
  const ez = THREE.MathUtils.degToRad(parseFloat(rz.value)||0);

  const qDelta = new THREE.Quaternion().setFromEuler(
  new THREE.Euler(ex, ey, ez, "XYZ")
);
  const qBase = initialBoneRot.get(b) || new THREE.Quaternion();
  b.quaternion.copy(qBase).multiply(qDelta);
}

/* ===== Zero selected bone ===== */
function zeroSelectedBone(){
    const idx = parseInt(getActiveBoneSel().value || "-1", 10);
  if (!skeleton || isNaN(idx) || !skeleton.bones[idx]) return;

  const b = skeleton.bones[idx];
  const qb = initialBoneRot.get(b);
  if (qb) b.quaternion.copy(qb);

  rx.value="0"; 
  ry.value="0"; 
  rz.value="0";
}

/* ===== Reset all bones to baseline ===== */
function resetAllBonesToInitial(){
  if (!skeleton) return;

  skeleton.bones.forEach(b=>{
    const q0 = initialBoneRot.get(b);
    if (q0) b.quaternion.copy(q0);
  });

  if (JOINT_BIND) {
    JOINT_BIND.forEach(obj=>{
      if (obj?.bone) obj.qBind = obj.bone.quaternion.clone();
    });
  }
}

  /* ===== Rig profile & axis ===== */
  let RIG_PROFILE = 'generic';
  function detectRigProfile(){
    const names = skeleton?.bones.map(b=>b.name.toLowerCase()).join(' ') || '';
    if (/\bmixamorig\b/.test(names)) RIG_PROFILE = 'mixamo';
    else RIG_PROFILE = 'generic';
    log(`Rig profile: ${RIG_PROFILE}`);
  }
  function axisFor(profile, key, defAxis){
    if (profile==='mixamo'){
      const map = {
        sh_fe_l:'x', sh_fe_r:'x',
        sh_aa_l:'z', sh_aa_r:'-z',
        sh_irer_l:'y', sh_irer_r:'x',
        el_fe_l:'x', el_fe_r:'x',
        fa_ps_l:'y', fa_ps_r:'y',
        wr_ps_l:'y', wr_ps_r:'y',
        wr_fe_l:'x', wr_fe_r:'x',
        wr_ru_l:'z', wr_ru_r:'z',
        hip_fe_l:'x', hip_fe_r:'x',
        hip_aa_l:'z', hip_aa_r:'z',
        hip_irer_l:'y', hip_irer_r:'y',
        knee_fe_l:'x', knee_fe_r:'x',
        ankle_dfpf_l:'x', ankle_dfpf_r:'x',
        foot_invev_l:'z', foot_invev_r:'z',
        trunk_fe:'x', trunk_lat:'z', trunk_rot:'y',
        cerv_fe:'x',  cerv_lat:'z',  cerv_rot:'y'
      };
      if (key in map) return map[key];
    }
    return defAxis;
  }

  /* ===== Bone finding ===== */
  const EXCLUDE = /(pelvis|root|clavicle|scapula)/i;
  function sideRegex(side){
    if (!side) return [/.*/];
    return side==='l'
      ? [/\bleft\b/i, /\b_left\b/i, /\.l\b/i, /_l\b/i, /\bl\b(?![a-z])/i, /mixamorig:.*left/i]
      : [/\bright\b/i, /\b_right\b/i, /\.r\b/i, /_r\b/i, /\br\b(?![a-z])/i, /mixamorig:.*right/i];
  }
  function findBoneBy(cfg){
    if (!skeleton) return null;
    const names = skeleton.bones.map(b=>b.name.toLowerCase());
    const sideREs = sideRegex(cfg.side);

    const HINTS = cfg.hints || [];
    const preferred = (/^trunk_/.test(cfg.key)) ? [/^spine01$/] :
                      (/^cerv_/.test(cfg.key))  ? [/^neck$/, /^head$/] : [];
    const tryList = preferred.length ? [...preferred, ...HINTS] : HINTS;

    for (const cand of tryList){
      for (let i=0;i<names.length;i++){
        if (EXCLUDE.test(names[i])) continue;
        if (cfg.side && !sideREs.some(r=>r.test(names[i])) ) continue;
        if (cand.test(names[i])) return skeleton.bones[i];
      }
    }
    if (!cfg.side){
      for (const cand of tryList){
        for (let i=0;i<names.length;i++){
          if (EXCLUDE.test(names[i])) continue;
          if (cand.test(names[i])) return skeleton.bones[i];
        }
      }
    }
    return null;
  }

  /* ===== DRUJ proxy (kept) ===== */
  const DRUJ = { l:null, r:null };
  function ensureDRUJProxy(side){
    if (!skeleton) return null;
    if (DRUJ[side]) return DRUJ[side];
    const handCfg = { side, hints:[/hand|wrist/i] };
    let hand = findBoneBy(handCfg);
    if (!hand) return null;
    const pivot = new THREE.Object3D();
    const parent = hand.parent; if (!parent) return null;
    parent.add(pivot);
    pivot.position.copy(hand.position);
    pivot.quaternion.copy(hand.quaternion);
    pivot.scale.copy(hand.scale);
    pivot.add(hand);
    hand.position.set(0,0,0); hand.quaternion.identity(); hand.scale.set(1,1,1);
    initialBoneRot.set(pivot, pivot.quaternion.clone());
    DRUJ[side] = { pivot };
    log(`Created DRUJ proxy for ${side.toUpperCase()}`);
    return DRUJ[side];
  }

  const JOINT_BIND = new Map();
  function resolveBind(key,cfg){
    if (JOINT_BIND.has(key)) return JOINT_BIND.get(key);
    if (/^trunk_/.test(key)) {
      const b = getExactBoneByName('spine01');
      if (b) {
        const qBind = (initialBoneRot.get(b) || b.quaternion.clone()).clone();
        const axis = axisFor(RIG_PROFILE, key, ({sagittal:'x', frontal:'z', transverse:'y'})[cfg.plane] || 'x');
        const obj = { bone: b, qBind, axis };
        JOINT_BIND.set(key, obj);
        log(`Bound ${key} → spine01 (axis ${axis}) [hard-bind]`);
        return obj;
      }
    }
    let bone = findBoneBy({...cfg, key});
    if ((!bone) && (key==='wr_ps_l' || key==='fa_ps_l')) { const p=ensureDRUJProxy('l'); bone=p&&p.pivot; }
    if ((!bone) && (key==='wr_ps_r' || key==='fa_ps_r')) { const p=ensureDRUJProxy('r'); bone=p&&p.pivot; }
    if (!bone) { log(`No bind for ${key}`); return null; }
    const qBind = (initialBoneRot.get(bone) || bone.quaternion.clone()).clone();
    const baseAxis = ({sagittal:'x',frontal:'z',transverse:'y'})[cfg.plane] || 'x';
    const axis = axisFor(RIG_PROFILE, key, baseAxis);
    const obj = {bone, qBind, axis};
    JOINT_BIND.set(key,obj);
    log(`Bound ${key} → ${bone.name} (axis ${axis})`);
    return obj;
  }

function freezeBindBaseFor(key, cfg) {
  const b = resolveBind(key, cfg);
  if (!b) return;
  b.qBind = b.bone.quaternion.clone();
}


    function applyPairAngle(key, cfg, deg) {
  const bind = resolveBind(key, cfg);
  if (!bind) return;

  const { bone, qBind, axis: rawAxis } = bind;

  // --- Right-shoulder rotation sign corrections ---
  if (key === 'sh_irer_r') deg = -deg;          // Shoulder IR/ER
  if (key === 'sh_aa_r')  deg = -deg;           // Shoulder Abd/Add (reverse direction)

    // --- Right-wrist direction fixes ---
  if (key === 'wr_ps_r') deg = -deg;  // flip pronation/supination
  if (key === 'wr_ru_r') deg = -deg;  // flip radial/ulnar deviation


  const rad = THREE.MathUtils.degToRad(deg + (cfg.neutral || 0));

  // Handle flipped axis (e.g. "-z" for mirrored rig)
  let x = 0, y = 0, z = 0;
  let flip = 1;
  let axis = rawAxis;
  if (axis.startsWith('-')) {
    flip = -1;
    axis = axis.slice(1);
  }

  const r = flip * rad;
  if (axis === 'x') x = r;
  if (axis === 'y') y = r;
  if (axis === 'z') z = r;

  const e = new THREE.Euler(x, y, z, "XYZ");
  const qDelta = new THREE.Quaternion().setFromEuler(e);
  bone.quaternion.copy(qBind).multiply(qDelta);

  // --- Debug: confirm right-shoulder direction ---
  if (CURRENT_ACTION?.key === "sh_aa_r") {
    console.log(
      `Right-shoulder: ${bone.name}, axis: ${axis}, flipped: ${flip === -1}, deg=${deg}, r=${r.toFixed(3)}`
    );
  }
}


  /* ===== Motions (paired configs; UI splits) ===== */
  const UPPER = [
    {key:'trunk_fe',  pair:'Trunk — Flex / Ext',            side:'', plane:'sagittal',   neutral:0, min:-60, max:80,  hints:[/^spine01$/i]},
    {key:'trunk_lat', pair:'Trunk — Lateral Bend (L / R)',  side:'', plane:'frontal',    neutral:0, min:-40, max:40,  hints:[/^spine01$/i]},
    {key:'trunk_rot', pair:'Trunk — Rotation (L / R)',      side:'', plane:'transverse', neutral:0, min:-45, max:45,  hints:[/^spine01$/i]},

    {key:'cerv_fe',   pair:'Cervical Flex / Ext',                side:'', plane:'sagittal',   neutral:0, min:-60,  max:70,  hints:[/^neck$|cspine|head/i]},
    {key:'cerv_lat',  pair:'Cervical Lat Flex (L / R)',          side:'', plane:'frontal',    neutral:0, min:-45,  max:45,  hints:[/^neck$|cspine|head/i]},
    {key:'cerv_rot',  pair:'Cervical Rotation (L / R)',          side:'', plane:'transverse', neutral:0, min:-80,  max:80,  hints:[/^neck$|cspine|head/i]},

    {key:'sh_fe_l',   pair:'Shoulder L — Flex / Ext',            side:'l', plane:'sagittal',  neutral:0, min:-60,  max:130, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_fe_r',   pair:'Shoulder R — Flex / Ext',            side:'r', plane:'sagittal',  neutral:0, min:-60,  max:130, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_l',   pair:'Shoulder L — Abd / Add',             side:'l', plane:'frontal',   neutral:0, min:-20,  max:170, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_aa_r',   pair:'Shoulder R — Abd / Add',             side:'r', plane:'frontal',   neutral:0, min:-20,  max:170, hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_l', pair:'Shoulder L — Internal / External',   side:'l', plane:'transverse',neutral:0, min:-50,  max:37,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},
    {key:'sh_irer_r', pair:'Shoulder R — Internal / External',   side:'r', plane:'transverse',neutral:0, min:-50,  max:37,  hints:[/upperarm|humerus|shoulder|arm(?!.*lower)/i]},

    // ELBOW — fix so Flexion moves (150), Extension small (10)
    {key:'el_fe_l',   pair:'Elbow L — Flex / Ext',               side:'l', plane:'sagittal',  neutral:0, min:-10,  max:120, hints:[/lowerarm|forearm|ulna|radius/i]},
    {key:'el_fe_r',   pair:'Elbow R — Flex / Ext',               side:'r', plane:'sagittal',  neutral:0, min:-10,  max:120, hints:[/lowerarm|forearm|ulna|radius/i]},

     // ===== Wrist — corrected direction for right side =====
    {key:'wr_ps_l', pair:'Wrist L — Pronation / Supination', side:'l', plane:'transverse', neutral:0, min:-45, max:70, hints:[/wrist|hand|forearm|radius|ulna/i]},
    {key:'wr_ps_r', pair:'Wrist R — Pronation / Supination', side:'r', plane:'transverse', neutral:0, min:-45, max:70, invert:true, hints:[/wrist|hand|forearm|radius|ulna/i]}, // 🔁 flipped

    {key:'wr_fe_l', pair:'Wrist L — Flex / Ext', side:'l', plane:'sagittal', neutral:0, min:-70, max:80, hints:[/wrist|hand/i]},
    {key:'wr_fe_r', pair:'Wrist R — Flex / Ext', side:'r', plane:'sagittal', neutral:0, min:-70, max:80, hints:[/wrist|hand/i]},

    {key:'wr_ru_l', pair:'Wrist L — Radial / Ulnar Dev', side:'l', plane:'frontal', neutral:0, min:-40, max:20, hints:[/wrist|hand/i]},
    {key:'wr_ru_r', pair:'Wrist R — Radial / Ulnar Dev', side:'r', plane:'frontal', neutral:0, min:-40, max:20, invert:true, hints:[/wrist|hand/i]}, // 🔁 flipped

];   
  const LOWER = [
    {key:'hip_fe_l',   pair:'Hip L — Flex / Ext',                side:'l', plane:'sagittal',  neutral:0, min:-30,  max:105, hints:[/thigh|femur/i]},
    {key:'hip_fe_r',   pair:'Hip R — Flex / Ext',                side:'r', plane:'sagittal',  neutral:0, min:-30,  max:105, hints:[/thigh|femur/i]},
    {key:'hip_aa_l',   pair:'Hip L — Abd / Add',                 side:'l', plane:'frontal',   neutral:0, min:-24,  max:45,  hints:[/thigh|femur/i]},
    {key:'hip_aa_r', pair:'Hip R — Add / Abd', side:'r', plane:'frontal', neutral:0, min:-24, max:45, hints:[/thigh|femur/i]},
    {key:'hip_irer_l', pair:'Hip L — Internal / External',       side:'l', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/thigh|femur/i]},
    {key:'hip_irer_r', pair:'Hip R — Internal / External',       side:'r', plane:'transverse',neutral:0, min:-45,  max:45,  hints:[/thigh|femur/i]},
    {key:'knee_fe_l', pair:'Knee L — Ext / Flex', side:'l', plane:'sagittal', neutral:0, min:-15, max:150, hints:[/calf|tibia|fibula|shin/i]},
    {key:'knee_fe_r', pair:'Knee R — Ext / Flex', side:'r', plane:'sagittal', neutral:0, min:-15, max:150, hints:[/calf|tibia|fibula|shin/i]},
    {key:'ankle_dfpf_l', pair:'Ankle L — Dorsi / Plantarflex',   side:'l', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'ankle_dfpf_r', pair:'Ankle R — Dorsi / Plantarflex',   side:'r', plane:'sagittal',  neutral:0, min:-20,  max:50,  hints:[/ankle|foot|talus|tarsal/i]},
    {key:'foot_invev_l', pair:'Foot L — Inversion / Eversion',   side:'l', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|metatars|heel/i]},
    {key:'foot_invev_r', pair:'Foot R — Inversion / Eversion',   side:'r', plane:'frontal',   neutral:0, min:-20,  max:35,  hints:[/foot|calcaneus|metatars|heel/i]},
  ];

  let CURRENT = UPPER;

  function dirEntriesFromPair(cfg){
    const absMin = Math.abs(cfg.min);
    const maxPos = cfg.max;
    const out = [];
    const push = (label, sign, maxVal) => out.push({ key: cfg.key, cfg, label, sign, max: maxVal });

    // Cervical — keep exact labels
    if (cfg.key === 'cerv_fe'){
      push('Cervical Flexion',  +1, maxPos);
      push('Cervical Extension', -1, absMin);
      return out;
    }
    if (cfg.key === 'cerv_lat'){
      push('Cervical Lateral Flexion — Left', -1, absMin);
      push('Cervical Lateral Flexion — Right',  +1, maxPos);
      return out;
    }
    if (cfg.key === 'cerv_rot'){
      push('Cervical Rotation — Right',  -1, absMin);
      push('Cervical Rotation — Left', +1, maxPos);
      return out;
    }

    // Shoulder Abd/Add — Right side normal orientation
   if (cfg.key==='sh_aa_r'){
  push('Shoulder R — Abduction', +1, maxPos);
  push('Shoulder R — Adduction', -1, absMin);
  return out;
}
    // Shoulder R IR/ER — explicit labels
if (cfg.key === 'sh_irer_r'){
  push('Shoulder R — Internal Rotation', +1, maxPos);
  push('Shoulder R — External Rotation', -1, absMin);
  return out;
}
 // === Hip Abduction / Adduction explicit labels ===
if (cfg.key === 'hip_aa_l'){
  push('Hip L — Abduction', +1, maxPos);
  push('Hip L — Adduction', -1, absMin);
  return out;
}
if (cfg.key === 'hip_aa_r'){
  push('Hip R — Abduction', -1, absMin);
  push('Hip R — Adduction', +1, maxPos);
  return out;
}

// --- Left Hip fix:  Internal ↔ External labels ---
if (cfg.key === 'hip_irer_l') {
  // External Rotation (positive)
  push(cfg.pair.replace(/—.*$/, '— Internal Rotation'), +1, maxPos);

  // Internal Rotation (negative)
  push(cfg.pair.replace(/—.*$/, '— External Rotation'), -1, absMin);

  return out;
}

// --- Right Hip fix:  Internal ↔ External labels ---
if (cfg.key === 'hip_irer_r') {
  // External Rotation (positive)
  push(cfg.pair.replace(/—.*$/, '— Internal Rotation'), -1, maxPos);

  // Internal Rotation (negative)
  push(cfg.pair.replace(/—.*$/, '— External Rotation'), +1, absMin);

  return out;
}

// --- Left Foot fix: 
if (cfg.key === 'foot_invev_l') {
  push(cfg.pair.replace(/—.*$/, '— Inversion'), -1, maxPos);
  push(cfg.pair.replace(/—.*$/, '— Eversion'), +1, absMin);
  return out;
}
    if (/^knee_fe_/.test(cfg.key)) {
  // 🔁 Knee bending = Flexion (+), straightening = Extension (−)
  push(cfg.pair.replace(/—.*$/, '— Flexion'), -1, maxPos);
  push(cfg.pair.replace(/—.*$/, '— Extension'), +1, absMin);
  }
  else if (/_fe_/.test(cfg.key) || cfg.key==='trunk_fe'){
  push(cfg.pair.replace(/—.*$/, '— Flexion'), +1, maxPos);
  push(cfg.pair.replace(/—.*$/, '— Extension'), -1, absMin);
    } else if (/_aa_/.test(cfg.key)){
      push(cfg.pair.replace(/—.*$/, '— Abduction'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Adduction'), -1, absMin);
    } else if (/_irer_/.test(cfg.key)){
      push(cfg.pair.replace(/—.*$/, '— Internal Rotation'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— External Rotation'), -1, absMin);
    } else if (cfg.key==='trunk_lat'){
      push(cfg.pair.replace(/—.*$/, '— Right Lateral Flexion'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Left Lateral Flexion'), -1, absMin);
    } else if (cfg.key==='trunk_rot'){
      push(cfg.pair.replace(/—.*$/, '— Left Rotation'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Right Rotation'), -1, absMin);
    } else if (/wr_ps_/.test(cfg.key)){
      // SWAP LABELS per your report: + == PRONATION, - == SUPINATION
      push(cfg.pair.replace(/—.*$/, '— Pronation'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Supination'), -1, absMin);
    } else if (/wr_fe_/.test(cfg.key)){
      push(cfg.pair.replace(/—.*$/, '— Flexion'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Extension'), -1, absMin);
    } else if (/wr_ru_/.test(cfg.key)){
      // SWAP LABELS per your report: + == RADIAL, - == ULNAR
      push(cfg.pair.replace(/—.*$/, '— Radial Deviation'), +1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Ulnar Deviation'), -1, absMin);
    } else if (/ankle_dfpf_/.test(cfg.key)){
      push(cfg.pair.replace(/—.*$/, '— Plantarflexion'), -1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Dorsiflexion'), +1, absMin);
    } else if (/foot_invev_/.test(cfg.key)){
      push(cfg.pair.replace(/—.*$/, '— Eversion'), -1, maxPos);
      push(cfg.pair.replace(/—.*$/, '— Inversion'), +1, absMin);
    }
    return out;
  }

  function buildSeparatedCatalog(list){
    const cat = {};
    const add = (grp, entries)=>{ if (!cat[grp]) cat[grp]=[]; cat[grp].push(...entries); };
    list.forEach(cfg=>{
      if (/^trunk_/.test(cfg.key)) add('Trunk', dirEntriesFromPair(cfg));
      else if (/^cerv_/.test(cfg.key)) add('Cervical', dirEntriesFromPair(cfg));
      else if (/^sh_/.test(cfg.key)) add('Shoulder', dirEntriesFromPair(cfg));
      else if (/^el_/.test(cfg.key)) add('Elbow', dirEntriesFromPair(cfg));
      // Forearm group intentionally NOT added (removed from UI)
      else if (/^wr_/.test(cfg.key)) add('Wrist', dirEntriesFromPair(cfg));
      else if (/^hip_/.test(cfg.key)) add('Hip', dirEntriesFromPair(cfg));
      else if (/^knee_/.test(cfg.key)) add('Knee', dirEntriesFromPair(cfg));
      else if (/^ankle_/.test(cfg.key)) add('Ankle', dirEntriesFromPair(cfg));
      else if (/^foot_/.test(cfg.key)) add('Foot', dirEntriesFromPair(cfg));
    });
    return cat;
  }

  let CURRENT_ACTION = null;
  function cfgFromKey(k){ return [...UPPER,...LOWER].find(x=>x.key===k) || null; }

  function fillActionMenu(){
    actionSel.innerHTML = "";
    const ph = document.createElement("option");
    ph.value = ""; ph.textContent = "(Select a motion…)";
    actionSel.appendChild(ph);

    const list = (CURRENT===UPPER) ? UPPER : LOWER;
    const catalog = buildSeparatedCatalog(list);
    Object.keys(catalog).forEach(group=>{
      const og = document.createElement("optgroup"); og.label = group;
      catalog[group].forEach(entry=>{
        const opt = document.createElement("option");
        opt.value = `sep:${entry.key}:${entry.sign}:${entry.max}`;
        opt.textContent = entry.label;
        og.appendChild(opt);
      });
      actionSel.appendChild(og);
    });

    actionSel.value = "";
    pairLabel.textContent = "Angle (°)";
    actionDeg.disabled = true;
    CURRENT_ACTION = null;
  }

  function syncActionUI(forceZero=false){
    if (!CURRENT_ACTION){
      actionDeg.disabled = true;
      pairLabel.textContent = "Angle (°)";
      return;
    }
    pairLabel.textContent = `${CURRENT_ACTION.label} — Angle (°)`;
    actionDeg.min = "0";
    actionDeg.max = String(CURRENT_ACTION.max);
    if (forceZero) actionDeg.value = "0";
    actionDeg.disabled = false;
  }

  segUpper.onclick = ()=>{ CURRENT = UPPER; segUpper.classList.add('on'); segLower.classList.remove('on'); fillActionMenu(); actionDeg.value='0'; actionDeg.disabled=true; };
  segLower.onclick = ()=>{ CURRENT = LOWER; segLower.classList.add('on'); segUpper.classList.remove('on'); fillActionMenu(); };

  // === Anatomic preset (preloaded) ===
const ANAT_PRESETS = {
  Roma: { addL:-32, psL:-2, wpsL:-73, hipAA: 1  },  
  Roman:  { addL: -64, psL:-4, wpsL:-73, hipAA: 10 }   //
};

let ANAT = { ...ANAT_PRESETS.Roman };

function _inferModelKey(){
  const sel = document.getElementById("modelSel");
  if (sel && (sel.value === "Roman" || sel.value === "Roma")) return sel.value;

  const u = new URL(location.href);
  const q = (u.searchParams.get("model") || "").trim();
  if (q === "Roman" || q === "Roma") return q;

  // fallback: infer from resolved MODEL_URL
  if (typeof MODEL_URL === "string" && /\/Roma_/i.test(MODEL_URL)) return "Roma";
  return "Roman";
}

function setAnatForModel(key){
  const k = ANAT_PRESETS[key] ? key : "Roman";
  ANAT = { ...ANAT_PRESETS[k] };
}

// run once on startup
setAnatForModel(_inferModelKey());

// ensure ANAT updates BEFORE your existing modelSel change handler runs
document.getElementById("modelSel")?.addEventListener(
  "change",
  (e) => setAnatForModel(e.target.value),
  { capture: true }
);
function applyAnatomicBaseline(){
  // 🦴 Apply identical baselines to both arms (no mirroring)
  setPair('sh_aa_l', ANAT.addL);
  setPair('sh_aa_r', ANAT.addL);
  setPair('hip_aa_l',  ANAT.hipAA);
  setPair('hip_aa_r', -ANAT.hipAA);

  // Forearm & wrist PS — apply same orientation to both
  setPair('fa_ps_l', ANAT.psL);
  setPair('fa_ps_r', ANAT.psL);
  setPair('wr_ps_l', ANAT.wpsL);
  setPair('wr_ps_r', -ANAT.wpsL);

  log(`Anatomic baseline applied (same for L/R) → ADD ${ANAT.addL}, Forearm PS ${ANAT.psL}, Wrist PS ${ANAT.wpsL}`);
}

  // Always return to anatomic when changing actions; then freeze bind
  actionSel.addEventListener("change", ()=>{
    breakFunctionalBecauseActionMoved();
    resetPainExpression(); 
    resetAllBonesToInitial();
    applyAnatomicBaseline();
    CURRENT_ACTION = null;
    const v = actionSel.value || "";
    if (v.startsWith("sep:")){
      const [, key, signStr, maxStr] = v.split(":");
      const cfg = cfgFromKey(key);
      CURRENT_ACTION = { mode:'sep', key, cfg, sign: parseInt(signStr,10), max: parseFloat(maxStr), label: actionSel.options[actionSel.selectedIndex].textContent };
      freezeBindBaseFor(key,cfg);

      // Shoulder IR/ER → set elbow to 90° baseline immediately
      if (key==='sh_irer_l' || key==='sh_irer_r'){
       const side = key.endsWith('_l') ? 'l' : 'r';
       setPair(`el_fe_${side}`, 90); // elbow flexion to 90°
        log(`Elbow ${side.toUpperCase()} set to 90° for shoulder rotation setup.`);
      }

      syncActionUI(true);
      return;
    }
    syncActionUI(true);
  });
///checkpoint 

function resetPainExpression(){
  if (!window.ROM_CASE_MODE.active || !window.ROM_CASE_MODE.token || !model) return;
  const token = window.ROM_CASE_MODE.token;

  model.traverse(o => {
    if (!o.isSkinnedMesh || !o.morphTargetDictionary || !o.morphTargetInfluences) return;
    token.painShapeKeys.forEach(s => {
      const idx = o.morphTargetDictionary[s.key];
      if (idx !== undefined) {
        o.morphTargetInfluences[idx] = 0;
      }
    });
  });
}

actionDeg.addEventListener("input", ()=> {
  if (!CURRENT_ACTION) return;
breakFunctionalBecauseActionMoved();
resetPainExpression(); // also prevents grimace carrying into anything else

  let val = Math.max(0, Math.min(CURRENT_ACTION.max, parseFloat(actionDeg.value)||0));
  let isImpairedMotion = false;
  let limitHit = false;

  // --- CASE MODE LOGIC: GRIMACE & LIMITS ---
  if (window.ROM_CASE_MODE.active && window.ROM_CASE_MODE.token) {
    const token  = window.ROM_CASE_MODE.token;
    const caseId = token.caseId || "";
    let cap = capFor(CURRENT_ACTION);

    // ==========================
    // CASE 1 — Cervical (original)
    // ==========================
    if (caseId === "case_001") {
      // For this lab case we only impair:
      //   - Cervical Rotation — Right
      //   - Cervical Lateral Flexion — Right
      if (CURRENT_ACTION.key === 'cerv_rot' || CURRENT_ACTION.key === 'cerv_lat') {
        const isRight = CURRENT_ACTION.label.includes('Right'); // menu label includes "Right"
        if (isRight) {
          // Map to impairment keys: cerv_rot_r / cerv_lat_r
          const impKey =
            CURRENT_ACTION.key === 'cerv_rot' ? 'cerv_rot_r' : 'cerv_lat_r';
          const imp = token.impairments && token.impairments[impKey];
          if (imp && typeof imp.max === 'number') {
            cap = imp.max;
            isImpairedMotion = true;
          }
        }
      }
    }

    // ==========================
    // CASE 2 — Right Hip ROM loss
    // ==========================
    else if (caseId === "case_002") {
      // Hip Flexion / Extension — same slider (hip_fe_r)
      if (CURRENT_ACTION.key === 'hip_fe_r') {
        const isFlex = CURRENT_ACTION.label.includes('Flexion');
        const isExt  = CURRENT_ACTION.label.includes('Extension');

        let impKey = null;
        if (isFlex) impKey = 'hip_flex_r';  // e.g. 50°
        else if (isExt) impKey = 'hip_ext_r'; // e.g. 5°

        if (impKey) {
          const imp = token.impairments && token.impairments[impKey];
          if (imp && typeof imp.max === 'number') {
            cap = imp.max;
            isImpairedMotion = true;
          }
        }
      }

      // Hip Abduction — only limit Abduction side (hip_aa_r)
      else if (CURRENT_ACTION.key === 'hip_aa_r') {
        const isAbd = CURRENT_ACTION.label.includes('Abduction');
        if (isAbd) {
          const imp = token.impairments && token.impairments['hip_abd_r']; // e.g. 20°
          if (imp && typeof imp.max === 'number') {
            cap = imp.max;
            isImpairedMotion = true;
          }
        }
      }
      // (Adduction & rotations stay normal for this case.)
    }

// ==========================
// CASE 3 — Cluster impairment (TRUNK)
// ==========================
else if (caseId === "case_003") {

  // Trunk Flexion / Extension — same slider (trunk_fe)
  if (CURRENT_ACTION.key === 'trunk_fe') {
    const isFlex = CURRENT_ACTION.label.includes('Flexion');
    const isExt  = CURRENT_ACTION.label.includes('Extension');

    let impKey = null;
    if (isFlex) impKey = 'trunk_flexion';        // 20°
    else if (isExt) impKey = 'trunk_extension';  // 5°

    const imp = token.impairments && token.impairments[impKey];
    if (imp && typeof imp.max === 'number') {
      cap = imp.max;
      isImpairedMotion = true;
    }
  }

  // Trunk Lateral Flexion — (trunk_lat) labels include Left/Right
  else if (CURRENT_ACTION.key === 'trunk_lat') {
    const isLeft  = CURRENT_ACTION.label.includes('Left');
    const isRight = CURRENT_ACTION.label.includes('Right');

    const impKey = isLeft ? 'trunk_lat_left' : (isRight ? 'trunk_lat_right' : null);
    const imp = impKey && token.impairments && token.impairments[impKey];
    if (imp && typeof imp.max === 'number') {
      cap = imp.max;            // 15°
      isImpairedMotion = true;
    }
  }

  // Trunk Rotation — (trunk_rot) labels include Left/Right
  else if (CURRENT_ACTION.key === 'trunk_rot') {
    const isLeft  = CURRENT_ACTION.label.includes('Left');
    const isRight = CURRENT_ACTION.label.includes('Right');

    const impKey = isLeft ? 'trunk_rot_left' : (isRight ? 'trunk_rot_right' : null);
    const imp = impKey && token.impairments && token.impairments[impKey];
    if (imp && typeof imp.max === 'number') {
      cap = imp.max;            // 20°
      isImpairedMotion = true;
    }
  }
}


    // ==========================
    // FUTURE CASES 
    // Add more blocks here:
    //
    // else if (caseId === "case_00") { ... }
    // else if (caseId === "case_00") { ... }
    //
    // No other logic in this handler needs to change.
    // ==========================

    // Apply Hard Stop and Grimace Trigger (unchanged)
    if (typeof cap === 'number' && val > cap) {
      val = cap;
      actionDeg.value = String(val);
      limitHit = true;

      if (isImpairedMotion && model) {
        // Apply grimace to ANY skinned mesh that has these shapekeys
        model.traverse(o => {
          if (!o.isSkinnedMesh || !o.morphTargetDictionary || !o.morphTargetInfluences) return;
          token.painShapeKeys.forEach(s => {
            const idx = o.morphTargetDictionary[s.key];
            if (idx !== undefined) {
              o.morphTargetInfluences[idx] = s.value;
            }
          });
        });

        if (!window.ROM_CASE_MODE.notes.cluesShown) {
          alert(token.notes.cluesNote);
          window.ROM_CASE_MODE.notes.cluesShown = true;
        }
      }

    } else if (isImpairedMotion && model) {
      // Slider back under the cap → relax grimace on all relevant meshes
      model.traverse(o => {
        if (!o.isSkinnedMesh || !o.morphTargetDictionary || !o.morphTargetInfluences) return;
        token.painShapeKeys.forEach(s => {
          const idx = o.morphTargetDictionary[s.key];
          if (idx !== undefined) {
            o.morphTargetInfluences[idx] = 0;
          }
        });
      });
    }

    if (limitHit) {
      log(`Motion Limit Hit (${CURRENT_ACTION.label}): max ${val}°`);
    }
  }

  // Signed degrees for the chosen direction
  let signed = CURRENT_ACTION.sign * val;

  // === Smooth IR/ER path (compose with Abd/Add from same baseline) ===
  if (CURRENT_ACTION.key==='sh_irer_l' || CURRENT_ACTION.key==='sh_irer_r'){
    const side = CURRENT_ACTION.key.endsWith('_l') ? 'l' : 'r';

    // keep elbow flexed for stability
    setPair(`el_fe_${side}`, 90);

    // RIGHT shoulder needs sign flip on your rig
    let rotDeg = signed;
    if (side === 'r') rotDeg = -rotDeg;

    // compute coupled Abd/Add amount (IR → Add, ER → Abd)
    const amt = Math.min(30, Math.abs(rotDeg)*0.3) * (rotDeg>0 ? -1 : +1); // − = Add, + = Abd

    // compose both rotations from the SAME base on the SAME bone
    const keyRot = `sh_irer_${side}`;
    const keyAA  = `sh_aa_${side}`;
    const cfgRot = cfgFromKey(keyRot), cfgAA = cfgFromKey(keyAA);
    const bR = resolveBind(keyRot, cfgRot);
    const bA = resolveBind(keyAA,  cfgAA);

    if (bR && bA && bR.bone === bA.bone){
      const base = bR.qBind.clone();

      const toQ = (axis, deg) => {
        const r = THREE.MathUtils.degToRad(deg);
        const e = new THREE.Euler(
          axis==='x'?r:0,
          axis==='y'?r:0,
          axis==='z'?r:0,
          "XYZ"
        );
        return new THREE.Quaternion().setFromEuler(e);
      };

      const qRot = toQ(bR.axis, rotDeg);
      const qAA  = toQ(bA.axis, amt);
      const q = base.clone().multiply(qRot).multiply(qAA);

      bR.bone.quaternion.copy(q);
    } else {
      // fallback if binds differ: still apply rotation (with R-side fix)
      applyPairAngle(keyRot, cfgRot, rotDeg);
    }
    return; // IMPORTANT: stop here so we don't also run the generic path
  }

  // === Generic path (everything else) ===
  applyPairAngle(CURRENT_ACTION.key, CURRENT_ACTION.cfg, signed);
});

  zeroAll.onclick = ()=>{
    resetAllBonesToInitial();
    applyAnatomicBaseline();
    actionSel.value = ""; actionDeg.value = "0"; actionDeg.disabled = true; 
    rx.value = "0"; ry.value = "0"; rz.value = "0";
    pairLabel.textContent = "Angle (°)";
    log("All motions zeroed → returned to anatomic baseline.");
  };

  /* ===== Model load (unchanged) ===== */
  function clearModel(){
    if (model) scene.remove(model);
    model = null; skeleton = null;
    initialBoneRot.clear(); JOINT_BIND.clear();
    boneSel.innerHTML = "";
    DRUJ.l = DRUJ.r = null;
  }
  function loadModel(){
    msg.textContent = "Loading…"; log("Loading model...");
    clearModel();
    loader.load(
      MODEL_URL,
      (gltf) => {
        model = gltf.scene;
        FACE_MESH = null;
        model.traverse(o => {
          if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; }
          if (o.isSkinnedMesh && !skeleton) skeleton = o.skeleton;
        });
        scene.add(model);
        groundSnap();
        msg.textContent = "✅ Model loaded";
        populateBones();
        detectRigProfile();
        fillActionMenu();
// 🧩 Fix the right shoulder alignment BEFORE binding baselines
const shoulderR = findBoneBy({ key: 'upperarm_R' });
if (shoulderR) {
  const qFix = new THREE.Quaternion().setFromEuler(
    new THREE.Euler(THREE.MathUtils.degToRad(30), 0, 0, 'XYZ')
  );
  shoulderR.applyQuaternion(qFix);
  log("Right shoulder alignment fix applied (pre-bind).");
}

// === Rebuild baselines with corrected orientations ===
//1️⃣ Clear and rebuild bind data AFTER shoulder correction
JOINT_BIND.clear();

// 2️⃣ Re-record each bone’s corrected quaternion as its new baseline
skeleton.bones.forEach(b => {
  initialBoneRot.set(b, b.quaternion.clone());
});

// 3️⃣ Now capture the new baseline for reference motions
resetAllBonesToInitial();

// 4️⃣ Apply anatomic offsets on top of corrected baseline
applyAnatomicBaseline();

// ✅ Enable anticollision by default
COLLIM.enabled = true;
if (antiBox) antiBox.checked = true;

log("Right-shoulder baseline rebaked.");
log("Anticollision default ON.");
log("Anatomic baseline applied on load.");
 },      
      (xhr) => { 
        const pct = xhr.lengthComputable ? Math.min(100, Math.round((xhr.loaded/xhr.total)*100)) : null;
        msg.textContent = pct !== null ? `Loading ${pct}%` : "Loading…";
      },
      (err) => { console.error(err); msg.textContent = "⚠️ Load error"; log(`Error: ${err?.message || err}`); }
    );
  }
  loadModel();
    
/* ===== Advanced controls wiring ===== */
boneSel.onchange  = ()=>{ syncBoneActive("left");  rx.value=ry.value=rz.value="0"; setBoneRotationFromUI(); };
boneSel2.onchange = ()=>{ syncBoneActive("right"); rx.value=ry.value=rz.value="0"; setBoneRotationFromUI(); };

[rx,ry,rz].forEach(el => el.addEventListener("input", setBoneRotationFromUI));

[mx,my,mz,ms,myaw].forEach(el => el.addEventListener("input", ()=>{
  if (!model) return;
  model.position.set(parseFloat(mx.value), parseFloat(my.value), parseFloat(mz.value));
  model.scale.setScalar(parseInt(ms.value)/100);
  model.rotation.y = THREE.MathUtils.degToRad(parseFloat(myaw.value));
}));

zeroBone.onclick = zeroSelectedBone;

resetModel.onclick = ()=>{
  mx.value="0"; my.value="0"; mz.value="0.6"; ms.value="125"; myaw.value="0";
  if (model){ model.position.set(0,0,0.6); model.scale.setScalar(1.25); model.rotation.y=0; }
  groundSnap();
};

  /* ===== Paired-joint helpers ===== */
  function setPair(key,deg){
    if (key === 'wr_ps_l') return rotateSideWristPS('l', deg);
    if (key === 'wr_ps_r') return rotateSideWristPS('r', deg);
    const cfg = cfgFromKey(key);
    if (cfg) applyPairAngle(key,cfg,deg);
  }
  function getExactBoneByName(name){
    if (!skeleton) return null;
    const lname = String(name).toLowerCase();
    return skeleton.bones.find(b => (b.name||'').toLowerCase() === lname) || null;
  }
  function rotateSideWristPS(side, deg){
    if (!skeleton) return;
    let wrist = side === 'l' ? getExactBoneByName('hand_l') : getExactBoneByName('hand_r');
    if (!wrist){
      wrist = findBoneBy({ side, hints:[/wrist|hand(?!.*thumb|.*index|.*middle|.*ring|.*pinky)/i], key: side==='l'?'wr_ps_l':'wr_ps_r' });
    }
    if (!wrist){ log(`No wrist bone for ${side}`); return; }
    const keyForAxis = side === 'l' ? 'fa_ps_l' : 'fa_ps_r';
    const axis = axisFor(RIG_PROFILE, keyForAxis, 'y');
    const qBind = (initialBoneRot.get(wrist) || wrist.quaternion.clone()).clone();
    const rad = THREE.MathUtils.degToRad(deg);
    const e = new THREE.Euler(0,0,0,'XYZ');
    if (axis==='x') e.set(rad,0,0,'XYZ');
    if (axis==='y') e.set(0,rad,0,'XYZ');
    if (axis==='z') e.set(0,0,rad,'XYZ');
    wrist.quaternion.copy(qBind).multiply(new THREE.Quaternion().setFromEuler(e));
    log(`Wrist ${side.toUpperCase()} (hand_${side}) PS = ${deg}°`);
  }
// =======================================================
// ➡️ INSERT NEW loadROMCaseMode FUNCTION (STEP 2B) HERE
// =======================================================

function loadROMCaseMode() {
  const token = new URLSearchParams(window.location.search).get("caseToken");
  const cfg   = token && ROM_CASE_TOKENS[token];

  if (!cfg) return;

  window.ROM_CASE_MODE.active       = true;
  window.ROM_CASE_MODE.token        = cfg;
  // --- CASE UI LOCKS (STEP 2A) ---
const t  = cfg;
const id = cfg.caseId || "";

// reset UI
segUpper.disabled = false; segLower.disabled = false;
segUpper.style.display = ""; segLower.style.display = "";

const advancedDetails = document.querySelector("details");
if (advancedDetails) advancedDetails.style.display = "";

// case-specific locks
if (id === "case_001") {            // Cervical
  segLower.disabled = true;
  segLower.style.display = "none";
  segUpper.click();
  if (advancedDetails) advancedDetails.style.display = "none";

} else if (id === "case_002") {     // Hip
  segUpper.disabled = true;
  segUpper.style.display = "none";
  segLower.click();
  if (advancedDetails) advancedDetails.style.display =
    (t.disableAdvancedMenu === false) ? "" : "none";

} else if (id === "case_003") {     // Cluster / Trunk
 segLower.disabled = true;
  segLower.style.display = "none";
  segUpper.click();
   if (advancedDetails) advancedDetails.style.display =
    (t.disableAdvancedMenu === false) ? "" : "none";
}

  window.ROM_CASE_MODE.impairments  = cfg.impairments || {};
  window.ROM_CASE_MODE.notes        = cfg.notes || {};
  const caseId = cfg.caseId || "";

  // --- 1. APPLY INITIAL POSE & COLLISION (case-specific) ---
  resetModel.click(); // start from your default baseline

  // ==========================
  // CASE 1 — Cervical AROM
  // ==========================
  if (caseId === "case_001") {
    // Enforce seated pose for cervical AROM
    mx.value  = "0";
    my.value  = "-0.25";
    mz.value  = "0.35";
    ms.value  = "100";
    myaw.value = "180";

    if (model) {
      model.position.set(0, -0.25, 0.35);
      model.scale.setScalar(1.0);
      model.rotation.y = THREE.MathUtils.degToRad(180);
    }

      // Set up cervical collision limits (Case 1 only)
    const imp = cfg.impairments || {};
    COLLIM.enabled = true;
    // Rotation
    if (imp.cerv_rot_r && typeof imp.cerv_rot_r.max === "number") {
      COLLIM.cervRotRMax = imp.cerv_rot_r.max;   // e.g. 30°
    }
    COLLIM.cervRotLMax = 80;                     // Left rotation WNL
    // Lateral flexion
    if (imp.cerv_lat_r && typeof imp.cerv_lat_r.max === "number") {
      COLLIM.cervLatRMax = imp.cerv_lat_r.max;   // e.g. 20°
    }
    COLLIM.cervLatLMax = 45;                     // Left lat flex WNL
    COLLIM.save();
  }


  // ==========================
  // CASE 2 — Right Hip ROM Loss
  // ==========================
  else if (caseId === "case_002") {
    // Pose: neutral standing / standard lab view
    // (You can tweak these later without changing other cases.)
    mx.value  = "0";
    my.value  = "0";
    mz.value  = "0.6";
    ms.value  = "125";
    myaw.value = "0";

    if (model) {
      model.position.set(0, 0, 0.6);
      model.scale.setScalar(1.25);
      model.rotation.y = 0;
    }

    // Hip collision overrides from case_002 impairments
    const imp = cfg.impairments || {};

    COLLIM.enabled     = true;
    // Right hip flexion  (e.g. 50°)
    if (imp.hip_flex_r?.max !== undefined)
      COLLIM.hipFlexRMax = imp.hip_flex_r.max;

    // Right hip extension (e.g. 5°)
    if (imp.hip_ext_r?.max !== undefined)
      COLLIM.hipExtRMax = imp.hip_ext_r.max;

    // Right hip abduction (e.g. 20°)
    if (imp.hip_abd_r?.max !== undefined)
      COLLIM.hipAbdRMax = imp.hip_abd_r.max;

    // Left side + adduction stay at your default WNL values
    COLLIM.save();
  }
// ==========================
// CASE 3 — Cluster Impairment (TRUNK)
// ==========================
else if (caseId === "case_003") {
  // Pose: neutral standing / standard lab view
  mx.value   = "0";
  my.value   = "0";
  mz.value   = "0.6";
  ms.value   = "125";
  myaw.value = "0";

  if (model) {
    model.position.set(0, 0, 0.6);
    model.scale.setScalar(1.25);
    model.rotation.y = 0;
  }

  // Trunk collision overrides from case_003 impairments
  const imp = cfg.impairments || {};
  COLLIM.enabled = true;

  // Flexion (20°)
  if (imp.trunk_flexion?.max !== undefined)
    COLLIM.trunkFlexMax = imp.trunk_flexion.max;

  // Extension (5°)
  if (imp.trunk_extension?.max !== undefined)
    COLLIM.trunkExtMax = imp.trunk_extension.max;

  // Lateral Flexion L/R (15° each)
  if (imp.trunk_lat_left?.max !== undefined)
    COLLIM.trunkLatLMax = imp.trunk_lat_left.max;

  if (imp.trunk_lat_right?.max !== undefined)
    COLLIM.trunkLatRMax = imp.trunk_lat_right.max;

  // Rotation L/R (20° each)
  if (imp.trunk_rot_left?.max !== undefined)
    COLLIM.trunkRotLMax = imp.trunk_rot_left.max;

  if (imp.trunk_rot_right?.max !== undefined)
    COLLIM.trunkRotRMax = imp.trunk_rot_right.max;

  COLLIM.save();
}

  // ==========================
  // FUTURE CASES (3–15)
  // ==========================
  // else if (caseId === "case_003") {
  //   // set pose + COLLIM overrides for that case here
  // }
  // else if (caseId === "case_004") { ... }
  //
  // No other parts of the script need to change when adding new cases.
  // ==========================

  // --- 2. DISPLAY CONSTANT NOTES (SENSATION) AND BANNER ---

  // Case Mode Banner
  const banner = document.createElement("div");
  banner.textContent = ` LAB CASE MODE: ${cfg.label}`;
  banner.style.cssText =
    "position:fixed; top:0; left:0; right:0; padding:6px; " +
    "background:#dc2626; color:#fff; text-align:center; " +
    "font-weight:bold; z-index:100;";
if (!document.getElementById("caseBanner")) {
  banner.id = "caseBanner";
  document.body.appendChild(banner);
} else {
  document.getElementById("caseBanner").textContent = ` LAB CASE MODE: ${cfg.label}`;
}

  // Constant Notes (Sensation) card
  if (cfg.notes && cfg.notes.constantNote) {
    const constantNote = document.createElement("div");
    constantNote.id = "caseConstantNote";
    constantNote.innerHTML = cfg.notes.constantNote
      .replace(/\n/g, "<br>")
      .replace(/  +/g, "");
    constantNote.style.cssText =
      "position:fixed; top:35px; right:12px; width:220px; padding:10px; " +
      "background:rgba(30,41,59,0.95); border:1px solid #334155; " +
      "border-radius:8px; font-size:13px; color:#e2e8f0; z-index:99; " +
      "white-space:pre-wrap; box-shadow:0 4px 8px rgba(0,0,0,0.3);";
const existing = document.getElementById("caseConstantNote");
if (existing) existing.remove();
document.body.appendChild(constantNote);
  }

    // Run the UI cleanup function (Step 2A)
    populateBones(); 
}

// ---------------------------------------------------------
//  new function before loadModel runs
// ---------------------------------------------------------
loadROMCaseMode();
/* ===== Hidden Anatomic Tuner (dev-only, non-mirrored) ===== */
let tunerEl = null, tunerVisible = false;
function ensureAnatomicTuner() {
  if (tunerEl) return tunerEl;
  tunerEl = document.createElement('div');
  Object.assign(tunerEl.style, {
    position: 'fixed',
    right: '16px',
    top: '16px',
    zIndex: 40,
    background: 'rgba(8,13,26,.96)',
    border: '1px solid #334155',
    borderRadius: '12px',
    padding: '10px',
    width: '280px',
    color: '#e2e8f0',
    font: '12px/1.3 system-ui,Segoe UI,Roboto',
    boxShadow: '0 8px 28px rgba(0,0,0,.4)',
    display: 'none'
  });
  tunerEl.innerHTML = `
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
      <strong style="font-size:13px;">Anatomic Position Tuner (dev)</strong>
      <button id="anatX" title="Close" style="margin-left:auto;background:transparent;border:0;color:#9fb0c9;font-size:16px;cursor:pointer;">✕</button>
    </div>
    <label style="display:block;margin-top:6px;opacity:.8">Shoulder ADD (°)</label>
    <div style="display:grid;grid-template-columns:1fr 50px;gap:6px;">
      <input id="addL" type="number" step="1">
      <input id="addR" type="number" step="1" disabled>
    </div>
    <label style="display:block;opacity:.8">Forearm PS (°) — sup(+), pro(−)</label>
    <div style="display:grid;grid-template-columns:1fr 50px;gap:6px;">
      <input id="psL" type="number" step="1">
      <input id="psR" type="number" step="1" disabled>
    </div>
    <label style="display:block;opacity:.8; margin-top:8px;">Wrist PS (°)</label>
    <div style="display:grid;grid-template-columns:1fr 50px;gap:6px;">
      <input id="wpsL" type="number" step="1">
      <input id="wpsR" type="number" step="1" disabled>
    </div>
    <div style="display:flex;gap:8px;margin-top:10px;">
      <button id="anatApply" class="mini" style="flex:1">Apply</button>
      <button id="anatZero" class="mini">Zero</button>
    </div>
  `;
  document.body.appendChild(tunerEl);

  // Element references
  const addL = tunerEl.querySelector('#addL'), addR = tunerEl.querySelector('#addR');
  const psL  = tunerEl.querySelector('#psL'),  psR  = tunerEl.querySelector('#psR');
  const wpsL = tunerEl.querySelector('#wpsL'), wpsR = tunerEl.querySelector('#wpsR');

  // Preload current baseline (no mirroring)
  function preload() {
    addL.value = String(ANAT.addL);
    psL.value  = String(ANAT.psL);
    wpsL.value = String(ANAT.wpsL);
    addR.value = String(ANAT.addL);
    psR.value  = String(ANAT.psL);
    wpsR.value = String(ANAT.wpsL);
  }

  // Keep right side identical to left (no inversion)
  function syncRight() {
    addR.value = String(+addL.value || 0);
    psR.value  = String(+psL.value  || 0);
    wpsR.value = String(+wpsL.value || 0);
  }

  preload();
  addL.addEventListener('input', syncRight);
  psL.addEventListener('input', syncRight);
  wpsL.addEventListener('input', syncRight);

  // Apply & Zero
  tunerEl.querySelector('#anatApply').onclick = () => {
    ANAT.addL = +addL.value || 0;
    ANAT.psL  = +psL.value  || 0;
    ANAT.wpsL = +wpsL.value || 0;
    applyAnatomicBaseline();
  };
  tunerEl.querySelector('#anatZero').onclick = () => {
    addL.value = psL.value = wpsL.value = '0';
    syncRight();
    ANAT.addL = ANAT.psL = ANAT.wpsL = 0;
    applyAnatomicBaseline();
  };
  tunerEl.querySelector('#anatX').onclick = () => {
    tunerEl.style.display = 'none';
    tunerVisible = false;
  };

  return tunerEl;
}

function toggleTuner(show) {
  ensureAnatomicTuner();
  tunerVisible = (show === undefined) ? !tunerVisible : !!show;
  tunerEl.style.display = tunerVisible ? 'block' : 'none';
}

// === Helper: immediately enforce a limit on Apply ===
function enforceLimit(key, sign, cap) {
  if (!CURRENT_ACTION || !actionDeg) return;
  let currentVal = parseFloat(actionDeg.value) || 0;
  const max = Math.abs(cap);
  if (sign > 0 && currentVal > max) currentVal = max;
  if (sign < 0 && currentVal > max) currentVal = max;
  actionDeg.value = String(max);
  actionDeg.dispatchEvent(new Event("input"));
}
/* ===== Collision Tuner (dev-only) ===== */
let colTunerEl = null, colTunerVisible = false;

function ensureCollisionTuner() {
  if (colTunerEl) return colTunerEl;
  colTunerEl = document.createElement("div");
  Object.assign(colTunerEl.style, {
    position: "fixed",
    right: "16px",
    top: "120px",
    zIndex: 41,
    background: "rgba(8,13,26,.96)",
    border: "1px solid #334155",
    borderRadius: "12px",
    padding: "10px",
    width: "360px",
    maxHeight: "80vh",
    overflowY: "auto",
    color: "#e2e8f0",
    font: "12px/1.3 system-ui,Segoe UI,Roboto",
    boxShadow: "0 8px 28px rgba(0,0,0,.4)",
    display: "none",
  });

  colTunerEl.innerHTML = `
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
    <strong style="font-size:13px;">Collision Tuner (dev)</strong>
    <span class="badge">Safe ROM Line</span>
    <button id="colX" title="Close"
      style="margin-left:auto;background:transparent;border:0;color:#9fb0c9;
             font-size:16px;cursor:pointer;">✕</button>
  </div>

  <!-- Upper body -->
  <div class="rom-row"><div class="rom-head">Trunk Lat — Left max (°)</div>
    <div style="flex:1"><input id="colTrunkLatL" type="number" step="1" min="0" max="90"></div></div>
  <div class="rom-row"><div class="rom-head">Trunk Lat — Right max (°)</div>
    <div style="flex:1"><input id="colTrunkLatR" type="number" step="1" min="0" max="90"></div></div>
  <hr style="border-color:#1c2941;opacity:.3;">
  <div class="rom-row"><div class="rom-head">Cervical Rot — Left max (°)</div>
    <div style="flex:1"><input id="cervL" type="number" step="1" min="0" max="90"></div></div>
  <div class="rom-row"><div class="rom-head">Cervical Rot — Right max (°)</div>
    <div style="flex:1"><input id="cervR" type="number" step="1" min="0" max="90"></div></div>

  <hr style="border-color:#1c2941;opacity:.3;margin:8px 0;">

  <!-- === Fixed Shoulder Section === -->
  <div class="rom-row"><div class="rom-head">Shoulder Ext — Left max (°)</div>
    <div style="flex:1"><input id="shExtL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Shoulder Ext — Right max (°)</div>
    <div style="flex:1"><input id="shExtR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Shoulder Add — Left max (°)</div>
    <div style="flex:1"><input id="shAddL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Shoulder Add — Right max (°)</div>
    <div style="flex:1"><input id="shAddR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Shoulder Abd — Left max (°)</div>
    <div style="flex:1"><input id="shAbdL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Shoulder Abd — Right max (°)</div>
    <div style="flex:1"><input id="shAbdR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Shoulder Flex — Left max (°)</div>
    <div style="flex:1"><input id="shFlexL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Shoulder Flex — Right max (°)</div>
    <div style="flex:1"><input id="shFlexR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Shoulder IR — Left max (°)</div>
    <div style="flex:1"><input id="shIRL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Shoulder IR — Right max (°)</div>
    <div style="flex:1"><input id="shIRR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Shoulder ER — Left max (°)</div>
    <div style="flex:1"><input id="shERL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Shoulder ER — Right max (°)</div>
    <div style="flex:1"><input id="shERR" type="number"></div></div>

  <hr style="border-color:#1c2941;opacity:.3;margin:8px 0;">

  <div class="rom-row"><div class="rom-head">Elbow Ext — Left max (°)</div>
    <div style="flex:1"><input id="elExtL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Elbow Ext — Right max (°)</div>
    <div style="flex:1"><input id="elExtR" type="number"></div></div>

    <div class="rom-row"><div class="rom-head">Elbow Flex — Left max (°)</div>
  <div style="flex:1"><input id="elFlexL" type="number"></div></div>
<div class="rom-row"><div class="rom-head">Elbow Flex — Right max (°)</div>
  <div style="flex:1"><input id="elFlexR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Wrist Sup — Left max (°)</div>
    <div style="flex:1"><input id="wrSupL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Wrist Sup — Right max (°)</div>
    <div style="flex:1"><input id="wrSupR" type="number"></div></div>

  <hr style="border-color:#1c2941;opacity:.3;margin:8px 0;">
  <div class="rom-row"><div class="rom-head">Hip Flex — Left max (°)</div>
    <div style="flex:1"><input id="hipFlexL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Hip Flex — Right max (°)</div>
    <div style="flex:1"><input id="hipFlexR" type="number"></div></div>

  <div class="rom-row"><div class="rom-head">Knee Flex — Left max (°)</div>
    <div style="flex:1"><input id="kneeFlexL" type="number"></div></div>
  <div class="rom-row"><div class="rom-head">Knee Flex — Right max (°)</div>
    <div style="flex:1"><input id="kneeFlexR" type="number"></div></div>

  <div style="display:flex;gap:8px;margin-top:10px;">
    <button id="colApply" class="mini" style="flex:1">Apply</button>
    <button id="colSave" class="mini">Save</button>
    <button id="colReset" class="mini">Reset</button>
  </div>
  <div style="opacity:.7;margin-top:6px;">
    Tip: with <em>Anticollision</em> ON, these caps are enforced.
    Shift+Click the checkbox to reopen this tuner.
  </div>`;

  document.body.appendChild(colTunerEl);
  const $ = (id) => colTunerEl.querySelector(id);

  // === Apply Button ===
  colTunerEl.querySelector("#colApply").onclick = () => {
    const assign = (prop, id) => { COLLIM[prop] = +$(id).value || COLLIM[prop]; };
    assign("trunkLatLMax", "#colTrunkLatL");
    assign("trunkLatRMax", "#colTrunkLatR");
    assign("cervRotLMax", "#cervL");
    assign("cervRotRMax", "#cervR");
    assign("cervLatLMax", "#cervLatL");
    assign("cervLatRMax", "#cervLatR");
    assign("shAddLMax", "#shAddL");
    assign("shAddRMax", "#shAddR");
    assign("shAbdLMax", "#shAbdL");
    assign("shAbdRMax", "#shAbdR");
    assign("shFlexLMax", "#shFlexL");
    assign("shFlexRMax", "#shFlexR");
    assign("shExtLMax", "#shExtL");
    assign("shExtRMax", "#shExtR");
    assign("elFlexLMax", "#elFlexL");
    assign("elFlexRMax", "#elFlexR");
    assign("wrSupLMax", "#wrSupL");
    assign("wrSupRMax", "#wrSupR");
    assign("hipFlexLMax", "#hipFlexL");
    assign("hipFlexRMax", "#hipFlexR");
    COLLIM.save(); COLLIM.enabled = true;
    log("✅ limits  applied.");
  };

  // === Preload Existing Values ===
  const preload = () => {
    $("#colTrunkLatL").value = COLLIM.trunkLatLMax;
    $("#colTrunkLatR").value = COLLIM.trunkLatRMax;
    $("#cervL").value = COLLIM.cervRotLMax;
    $("#cervR").value = COLLIM.cervRotRMax;
    $("#cervLatL").value = COLLIM.cervLatLMax;
    $("#cervLatR").value = COLLIM.cervLatRMax;
    $("#shAddL").value = COLLIM.shAddLMax;
    $("#shAddR").value = COLLIM.shAddRMax;
    $("#shAbdL").value = COLLIM.shAbdLMax;
    $("#shAbdR").value = COLLIM.shAbdRMax;
    $("#shFlexL").value = COLLIM.shFlexLMax;
    $("#shFlexR").value = COLLIM.shFlexRMax;
    $("#elFlexL").value = COLLIM.elFlexLMax;
    $("#elFlexR").value = COLLIM.elFlexRMax;
    $("#wrSupL").value = COLLIM.wrSupLMax;
    $("#wrSupR").value = COLLIM.wrSupRMax;
    $("#hipFlexL").value = COLLIM.hipFlexLMax;
    $("#hipFlexR").value = COLLIM.hipFlexRMax;
  };
  preload();

  colTunerEl.querySelector("#colX").onclick = () => toggleCollisionTuner(false);
  return colTunerEl;
}

function toggleCollisionTuner(show) {
  ensureCollisionTuner();
  COLLIM.load();
  colTunerVisible = show === undefined ? !colTunerVisible : !!show;
  colTunerEl.style.display = colTunerVisible ? "block" : "none";
}

  /* ===== Resize & render ===== */
  addEventListener("resize", () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  (function animate(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  })();
  </script>
</body>
</html>

